var l = Object.defineProperty;
var u = (n, t, r) => t in n ? l(n, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : n[t] = r;
var a = (n, t, r) => (u(n, typeof t != "symbol" ? t + "" : t, r), r);
const g = function(n, t) {
  const r = {};
  for (const e in n) {
    const s = n[e];
    t.indexOf(e) > -1 && s !== null && (r[e] = s);
  }
  return r;
}, h = (n) => n === "email", f = () => ({
  singleTag: "hr"
}), d = () => ({
  tag: "blockquote"
}), p = () => ({
  tag: "ul"
}), m = (n) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: n.attrs
    }
  ]
}), k = () => ({
  singleTag: "br"
}), $ = (n) => ({
  tag: `h${n.attrs.level}`
}), T = (n) => ({
  singleTag: [
    {
      tag: "img",
      attrs: g(n.attrs, ["src", "alt", "title"])
    }
  ]
}), y = () => ({
  tag: "li"
}), b = () => ({
  tag: "ol"
}), M = () => ({
  tag: "p"
}), j = (n) => ({
  tag: [
    {
      tag: "span",
      attrs: {
        ["data-type"]: "emoji",
        ["data-name"]: n.attrs.name
      }
    }
  ]
}), v = () => ({
  tag: "b"
}), E = () => ({
  tag: "strike"
}), x = () => ({
  tag: "u"
}), N = () => ({
  tag: "strong"
}), _ = () => ({
  tag: "code"
}), H = () => ({
  tag: "i"
}), S = (n) => {
  const t = { ...n.attrs }, { linktype: r = "url" } = n.attrs;
  if (h(r) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {
    for (const e in t.custom)
      t[e] = t.custom[e];
    delete t.custom;
  }
  return {
    tag: [
      {
        tag: "a",
        attrs: t
      }
    ]
  };
}, z = (n) => ({
  tag: [
    {
      tag: "span",
      attrs: n.attrs
    }
  ]
}), O = () => ({
  tag: "sub"
}), q = () => ({
  tag: "sup"
}), w = {
  nodes: {
    horizontal_rule: f,
    blockquote: d,
    bullet_list: p,
    code_block: m,
    hard_break: k,
    heading: $,
    image: T,
    list_item: y,
    ordered_list: b,
    paragraph: M,
    emoji: j
  },
  marks: {
    bold: v,
    strike: E,
    underline: x,
    strong: N,
    code: _,
    italic: H,
    link: S,
    styled: z,
    subscript: O,
    superscript: q
  }
}, C = function(n) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, r = /[&<>"']/g, e = RegExp(r.source);
  return n && e.test(n) ? n.replace(r, (s) => t[s]) : n;
};
class A {
  constructor(t) {
    a(this, "marks");
    a(this, "nodes");
    t || (t = w), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, r) {
    this.nodes[t] = r;
  }
  addMark(t, r) {
    this.marks[t] = r;
  }
  render(t, r = { optimizeImages: !1 }) {
    if (t && t.content && Array.isArray(t.content)) {
      let e = "";
      return t.content.forEach((s) => {
        e += this.renderNode(s);
      }), r.optimizeImages ? e.replace(/a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g, "a.storyblok.com/f/$1/$2.$3/m/") : e;
    }
    return console.warn(
      "The render method must receive an object with a content field, which is an array"
    ), "";
  }
  renderNode(t) {
    const r = [];
    t.marks && t.marks.forEach((s) => {
      const o = this.getMatchingMark(s);
      o && r.push(this.renderOpeningTag(o.tag));
    });
    const e = this.getMatchingNode(t);
    return e && e.tag && r.push(this.renderOpeningTag(e.tag)), t.content ? t.content.forEach((s) => {
      r.push(this.renderNode(s));
    }) : t.text ? r.push(C(t.text)) : e && e.singleTag ? r.push(this.renderTag(e.singleTag, " /")) : e && e.html && r.push(e.html), e && e.tag && r.push(this.renderClosingTag(e.tag)), t.marks && t.marks.slice(0).reverse().forEach((s) => {
      const o = this.getMatchingMark(s);
      o && r.push(this.renderClosingTag(o.tag));
    }), r.join("");
  }
  renderTag(t, r) {
    return t.constructor === String ? `<${t}${r}>` : t.map((s) => {
      if (s.constructor === String)
        return `<${s}${r}>`;
      {
        let o = `<${s.tag}`;
        if (s.attrs)
          for (const c in s.attrs) {
            const i = s.attrs[c];
            i !== null && (o += ` ${c}="${i}"`);
          }
        return `${o}${r}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((e) => e.constructor === String ? `</${e}>` : `</${e.tag}>`).join("");
  }
  getMatchingNode(t) {
    const r = this.nodes[t.type];
    if (typeof r == "function")
      return r(t);
  }
  getMatchingMark(t) {
    const r = this.marks[t.type];
    if (typeof r == "function")
      return r(t);
  }
}
export {
  A as default
};
