var v = Object.defineProperty;
var T = (o, t, e) => t in o ? v(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var h = (o, t, e) => (T(o, typeof t != "symbol" ? t + "" : t, e), e);
function $(o) {
  return !(o !== o || o === 1 / 0 || o === -1 / 0);
}
function w(o, t, e) {
  if (!$(t))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!$(e))
    throw new TypeError("Expected `interval` to be a finite number");
  const r = [];
  let s = [], i = 0;
  const n = function() {
    i++;
    const a = setTimeout(function() {
      i--, r.length > 0 && n(), s = s.filter(function(u) {
        return u !== a;
      });
    }, e);
    s.indexOf(a) < 0 && s.push(a);
    const l = r.shift();
    l.resolve(o.apply(l.self, l.args));
  }, c = function(...a) {
    const l = this;
    return new Promise(function(u, g) {
      r.push({
        resolve: u,
        reject: g,
        args: a,
        self: l
      }), i < t && n();
    });
  };
  return c.abort = function() {
    s.forEach(clearTimeout), s = [], r.forEach(function(a) {
      a.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), r.length = 0;
  }, c;
}
const x = function(o, t) {
  const e = {};
  for (const r in o) {
    const s = o[r];
    t.indexOf(r) > -1 && s !== null && (e[r] = s);
  }
  return e;
}, P = (o) => o === "email", S = () => ({
  singleTag: "hr"
}), C = () => ({
  tag: "blockquote"
}), E = () => ({
  tag: "ul"
}), A = (o) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: o.attrs
    }
  ]
}), O = () => ({
  singleTag: "br"
}), U = (o) => ({
  tag: `h${o.attrs.level}`
}), j = (o) => ({
  singleTag: [
    {
      tag: "img",
      attrs: x(o.attrs, ["src", "alt", "title"])
    }
  ]
}), L = () => ({
  tag: "li"
}), z = () => ({
  tag: "ol"
}), H = () => ({
  tag: "p"
}), M = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: {
        ["data-type"]: "emoji",
        ["data-name"]: o.attrs.name,
        emoji: o.attrs.emoji
      }
    }
  ]
}), N = () => ({
  tag: "b"
}), q = () => ({
  tag: "strike"
}), I = () => ({
  tag: "u"
}), F = () => ({
  tag: "strong"
}), V = () => ({
  tag: "code"
}), J = () => ({
  tag: "i"
}), K = (o) => {
  const t = { ...o.attrs }, { linktype: e = "url" } = o.attrs;
  if (P(e) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {
    for (const r in t.custom)
      t[r] = t.custom[r];
    delete t.custom;
  }
  return {
    tag: [
      {
        tag: "a",
        attrs: t
      }
    ]
  };
}, Q = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
}), W = () => ({
  tag: "sub"
}), B = () => ({
  tag: "sup"
}), G = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
}), X = (o) => {
  var e;
  return (e = o.attrs) != null && e.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `background-color:${o.attrs.color};`
        }
      }
    ]
  } : {
    tag: ""
  };
}, Y = (o) => {
  var e;
  return (e = o.attrs) != null && e.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `color:${o.attrs.color}`
        }
      }
    ]
  } : {
    tag: ""
  };
}, Z = {
  nodes: {
    horizontal_rule: S,
    blockquote: C,
    bullet_list: E,
    code_block: A,
    hard_break: O,
    heading: U,
    image: j,
    list_item: L,
    ordered_list: z,
    paragraph: H,
    emoji: M
  },
  marks: {
    bold: N,
    strike: q,
    underline: I,
    strong: F,
    code: V,
    italic: J,
    link: K,
    styled: Q,
    subscript: W,
    superscript: B,
    anchor: G,
    highlight: X,
    textStyle: Y
  }
}, D = function(o) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, e = /[&<>"']/g, r = RegExp(e.source);
  return o && r.test(o) ? o.replace(e, (s) => t[s]) : o;
};
class _ {
  constructor(t) {
    h(this, "marks");
    h(this, "nodes");
    t || (t = Z), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, e) {
    this.nodes[t] = e;
  }
  addMark(t, e) {
    this.marks[t] = e;
  }
  render(t, e = { optimizeImages: !1 }) {
    if (t && t.content && Array.isArray(t.content)) {
      let r = "";
      return t.content.forEach((s) => {
        r += this.renderNode(s);
      }), e.optimizeImages ? this.optimizeImages(r, e.optimizeImages) : r;
    }
    return console.warn(
      `The render method must receive an Object with a "content" field.
			The "content" field must be an array of nodes as the type ISbRichtext.
			ISbRichtext:
				content?: ISbRichtext[]
				marks?: ISbRichtext[]
				attrs?: any
				text?: string
				type: string
				
				Example:
				{
					content: [
						{
							content: [
								{
									text: 'Hello World',
									type: 'text'
								}
							],
							type: 'paragraph'
						}
					],
					type: 'doc'
				}`
    ), "";
  }
  optimizeImages(t, e) {
    let r = 0, s = 0, i = "", n = "";
    typeof e != "boolean" && (typeof e.width == "number" && e.width > 0 && (i += `width="${e.width}" `, r = e.width), typeof e.height == "number" && e.height > 0 && (i += `height="${e.height}" `, s = e.height), (e.loading === "lazy" || e.loading === "eager") && (i += `loading="${e.loading}" `), typeof e.class == "string" && e.class.length > 0 && (i += `class="${e.class}" `), e.filters && (typeof e.filters.blur == "number" && e.filters.blur >= 0 && e.filters.blur <= 100 && (n += `:blur(${e.filters.blur})`), typeof e.filters.brightness == "number" && e.filters.brightness >= -100 && e.filters.brightness <= 100 && (n += `:brightness(${e.filters.brightness})`), e.filters.fill && (e.filters.fill.match(/[0-9A-Fa-f]{6}/g) || e.filters.fill === "transparent") && (n += `:fill(${e.filters.fill})`), e.filters.format && ["webp", "png", "jpeg"].includes(e.filters.format) && (n += `:format(${e.filters.format})`), typeof e.filters.grayscale == "boolean" && e.filters.grayscale && (n += ":grayscale()"), typeof e.filters.quality == "number" && e.filters.quality >= 0 && e.filters.quality <= 100 && (n += `:quality(${e.filters.quality})`), e.filters.rotate && [90, 180, 270].includes(e.filters.rotate) && (n += `:rotate(${e.filters.rotate})`), n.length > 0 && (n = "/filters" + n))), i.length > 0 && (t = t.replace(/<img/g, `<img ${i.trim()}`));
    const c = r > 0 || s > 0 || n.length > 0 ? `${r}x${s}${n}` : "";
    return t = t.replace(
      /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,
      `a.storyblok.com/f/$1/$2.$3/m/${c}`
    ), typeof e != "boolean" && (e.sizes || e.srcset) && (t = t.replace(/<img.*?src=["|'](.*?)["|']/g, (a) => {
      var u, g;
      const l = a.match(
        /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g
      );
      if (l && l.length > 0) {
        const d = {
          srcset: (u = e.srcset) == null ? void 0 : u.map((f) => {
            if (typeof f == "number")
              return `//${l}/m/${f}x0${n} ${f}w`;
            if (typeof f == "object" && f.length === 2) {
              let k = 0, R = 0;
              return typeof f[0] == "number" && (k = f[0]), typeof f[1] == "number" && (R = f[1]), `//${l}/m/${k}x${R}${n} ${k}w`;
            }
          }).join(", "),
          sizes: (g = e.sizes) == null ? void 0 : g.map((f) => f).join(", ")
        };
        let y = "";
        return d.srcset && (y += `srcset="${d.srcset}" `), d.sizes && (y += `sizes="${d.sizes}" `), a.replace(/<img/g, `<img ${y.trim()}`);
      }
      return a;
    })), t;
  }
  renderNode(t) {
    const e = [];
    t.marks && t.marks.forEach((s) => {
      const i = this.getMatchingMark(s);
      i && i.tag !== "" && e.push(this.renderOpeningTag(i.tag));
    });
    const r = this.getMatchingNode(t);
    return r && r.tag && e.push(this.renderOpeningTag(r.tag)), t.content ? t.content.forEach((s) => {
      e.push(this.renderNode(s));
    }) : t.text ? e.push(D(t.text)) : r && r.singleTag ? e.push(this.renderTag(r.singleTag, " /")) : r && r.html ? e.push(r.html) : t.type === "emoji" && e.push(this.renderEmoji(t)), r && r.tag && e.push(this.renderClosingTag(r.tag)), t.marks && t.marks.slice(0).reverse().forEach((s) => {
      const i = this.getMatchingMark(s);
      i && i.tag !== "" && e.push(this.renderClosingTag(i.tag));
    }), e.join("");
  }
  renderTag(t, e) {
    return t.constructor === String ? `<${t}${e}>` : t.map((s) => {
      if (s.constructor === String)
        return `<${s}${e}>`;
      {
        let i = `<${s.tag}`;
        if (s.attrs)
          for (const n in s.attrs) {
            const c = s.attrs[n];
            c !== null && (i += ` ${n}="${c}"`);
          }
        return `${i}${e}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((r) => r.constructor === String ? `</${r}>` : `</${r.tag}>`).join("");
  }
  getMatchingNode(t) {
    const e = this.nodes[t.type];
    if (typeof e == "function")
      return e(t);
  }
  getMatchingMark(t) {
    const e = this.marks[t.type];
    if (typeof e == "function")
      return e(t);
  }
  renderEmoji(t) {
    if (t.attrs.emoji)
      return t.attrs.emoji;
    const e = [
      {
        tag: "img",
        attrs: {
          src: t.attrs.fallbackImage,
          draggable: "false",
          loading: "lazy",
          align: "absmiddle"
        }
      }
    ];
    return this.renderTag(e, " /");
  }
}
class b {
  constructor() {
    h(this, "isCDNUrl", (t = "") => t.indexOf("/cdn/") > -1);
    h(this, "getOptionsPage", (t, e = 25, r = 1) => ({
      ...t,
      per_page: e,
      page: r
    }));
    h(this, "delay", (t) => new Promise((e) => setTimeout(e, t)));
    h(this, "arrayFrom", (t = 0, e) => [...Array(t)].map(e));
    h(this, "range", (t = 0, e = t) => {
      const r = Math.abs(e - t) || 0, s = t < e ? 1 : -1;
      return this.arrayFrom(r, (i, n) => n * s + t);
    });
    h(this, "asyncMap", async (t, e) => Promise.all(t.map(e)));
    h(this, "flatMap", (t = [], e) => t.map(e).reduce((r, s) => [...r, ...s], []));
  }
  /**
   * @method stringify
   * @param  {Object} params
   * @param  {String} prefix
   * @param  {Boolean} isArray
   * @return {String} Stringified object
   */
  stringify(t, e, r) {
    const s = [];
    for (const i in t) {
      if (!Object.prototype.hasOwnProperty.call(t, i))
        continue;
      const n = t[i], c = r ? "" : encodeURIComponent(i);
      let a;
      typeof n == "object" ? a = this.stringify(
        n,
        e ? e + encodeURIComponent("[" + c + "]") : c,
        Array.isArray(n)
      ) : a = (e ? e + encodeURIComponent("[" + c + "]") : c) + "=" + encodeURIComponent(n), s.push(a);
    }
    return s.join("&");
  }
  /**
   * @method getRegionURL
   * @param  {String} regionCode region code, could be eu, us or cn
   * @return {String} The base URL of the region
   */
  getRegionURL(t) {
    const e = "api.storyblok.com", r = "api-us.storyblok.com", s = "app.storyblokchina.cn";
    switch (t) {
      case "us":
        return r;
      case "cn":
        return s;
      default:
        return e;
    }
  }
}
class tt {
  constructor(t) {
    h(this, "baseURL");
    h(this, "timeout");
    h(this, "headers");
    h(this, "responseInterceptor");
    h(this, "fetch");
    h(this, "ejectInterceptor");
    h(this, "url");
    h(this, "parameters");
    this.baseURL = t.baseURL, this.headers = t.headers || new Headers(), this.timeout = t != null && t.timeout ? t.timeout * 1e3 : 0, this.responseInterceptor = t.responseInterceptor, this.fetch = (...e) => t.fetch ? t.fetch(...e) : fetch(...e), this.ejectInterceptor = !1, this.url = "", this.parameters = {};
  }
  /**
   *
   * @param url string
   * @param params ISbStoriesParams
   * @returns Promise<ISbResponse | Error>
   */
  get(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("get");
  }
  post(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("post");
  }
  put(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("put");
  }
  delete(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("delete");
  }
  async _responseHandler(t) {
    const e = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    t.status !== 204 && await t.json().then((s) => {
      r.data = s;
    });
    for (const s of t.headers.entries())
      e[s[0]] = s[1];
    return r.headers = { ...e }, r.status = t.status, r.statusText = t.statusText, r;
  }
  async _methodHandler(t) {
    let e = `${this.baseURL}${this.url}`, r = null;
    if (t === "get") {
      const a = new b();
      e = `${this.baseURL}${this.url}?${a.stringify(
        this.parameters
      )}`;
    } else
      r = JSON.stringify(this.parameters);
    const s = new URL(e), i = new AbortController(), { signal: n } = i;
    let c;
    this.timeout && (c = setTimeout(() => i.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s}`, {
        method: t,
        headers: this.headers,
        body: r,
        signal: n
      });
      this.timeout && clearTimeout(c);
      const l = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(l)) : this._statusHandler(l);
    } catch (a) {
      return {
        message: a
      };
    }
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  _statusHandler(t) {
    const e = /20[0-6]/g;
    return new Promise((r, s) => {
      if (e.test(`${t.status}`))
        return r(t);
      const i = {
        message: new Error(t.statusText),
        status: t.status,
        response: Array.isArray(t.data) ? t.data[0] : t.data.error || t.data.slug
      };
      s(i);
    });
  }
}
let m = {};
const p = {};
class rt {
  /**
   *
   * @param config ISbConfig interface
   * @param endpoint string, optional
   */
  constructor(t, e) {
    h(this, "client");
    h(this, "maxRetries");
    h(this, "throttle");
    h(this, "accessToken");
    h(this, "cache");
    h(this, "helpers");
    h(this, "resolveCounter");
    h(this, "relations");
    h(this, "links");
    h(this, "richTextResolver");
    h(this, "resolveNestedRelations");
    if (!e) {
      const i = new b().getRegionURL, n = t.https === !1 ? "http" : "https";
      t.oauthToken ? e = `${n}://${i(t.region)}/v1` : e = `${n}://${i(t.region)}/v2`;
    }
    const r = new Headers();
    r.set("Content-Type", "application/json"), r.set("Accept", "application/json"), r.forEach((i, n) => {
      t.headers && t.headers[n] && r.set(n, t.headers[n]);
    });
    let s = 5;
    t.oauthToken && (r.set("Authorization", t.oauthToken), s = 3), t.rateLimit && (s = t.rateLimit), t.richTextSchema ? this.richTextResolver = new _(t.richTextSchema) : this.richTextResolver = new _(), t.componentResolver && this.setComponentResolver(t.componentResolver), this.maxRetries = t.maxRetries || 5, this.throttle = w(this.throttledRequest, s, 1e3), this.accessToken = t.accessToken || "", this.relations = {}, this.links = {}, this.cache = t.cache || { clear: "manual" }, this.helpers = new b(), this.resolveCounter = 0, this.resolveNestedRelations = t.resolveNestedRelations || !0, this.client = new tt({
      baseURL: e,
      timeout: t.timeout || 0,
      headers: r,
      responseInterceptor: t.responseInterceptor,
      fetch: t.fetch
    });
  }
  setComponentResolver(t) {
    this.richTextResolver.addNode("blok", (e) => {
      let r = "";
      return e.attrs.body && e.attrs.body.forEach((s) => {
        r += t(s.component, s);
      }), {
        html: r
      };
    });
  }
  parseParams(t) {
    return t.version || (t.version = "published"), t.token || (t.token = this.getToken()), t.cv || (t.cv = p[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")), t;
  }
  factoryParamOptions(t, e) {
    return this.helpers.isCDNUrl(t) ? this.parseParams(e) : e;
  }
  makeRequest(t, e, r, s) {
    const i = this.factoryParamOptions(
      t,
      this.helpers.getOptionsPage(e, r, s)
    );
    return this.cacheResponse(t, i);
  }
  get(t, e) {
    e || (e = {});
    const r = `/${t}`, s = this.factoryParamOptions(r, e);
    return this.cacheResponse(r, s);
  }
  async getAll(t, e, r) {
    const s = (e == null ? void 0 : e.per_page) || 25, i = `/${t}`, n = i.split("/"), c = r || n[n.length - 1], a = 1, l = await this.makeRequest(i, e, s, a), u = l.total ? Math.ceil(l.total / s) : 1, g = await this.helpers.asyncMap(
      this.helpers.range(a, u),
      (d) => this.makeRequest(i, e, s, d + 1)
    );
    return this.helpers.flatMap(
      [l, ...g],
      (d) => Object.values(d.data[c])
    );
  }
  post(t, e) {
    const r = `/${t}`;
    return Promise.resolve(this.throttle("post", r, e));
  }
  put(t, e) {
    const r = `/${t}`;
    return Promise.resolve(this.throttle("put", r, e));
  }
  delete(t, e) {
    const r = `/${t}`;
    return Promise.resolve(this.throttle("delete", r, e));
  }
  getStories(t) {
    return this.get("cdn/stories", t);
  }
  getStory(t, e) {
    return this.get(`cdn/stories/${t}`, e);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _cleanCopy(t) {
    return JSON.parse(JSON.stringify(t));
  }
  _insertLinks(t, e, r) {
    const s = t[e];
    s && s.fieldtype == "multilink" && s.linktype == "story" && typeof s.id == "string" && this.links[r][s.id] ? s.story = this._cleanCopy(this.links[r][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[r][s.uuid] && (s.story = this._cleanCopy(this.links[r][s.uuid]));
  }
  _insertRelations(t, e, r, s) {
    if (r.indexOf(`${t.component}.${e}`) > -1) {
      if (typeof t[e] == "string")
        this.relations[s][t[e]] && (t[e] = this._cleanCopy(
          this.relations[s][t[e]]
        ));
      else if (t[e] && t[e].constructor === Array) {
        const i = [];
        t[e].forEach((n) => {
          this.relations[s][n] && i.push(this._cleanCopy(this.relations[s][n]));
        }), t[e] = i;
      }
    }
  }
  iterateTree(t, e, r) {
    const s = (i) => {
      if (i != null) {
        if (i.constructor === Array)
          for (let n = 0; n < i.length; n++)
            s(i[n]);
        else if (i.constructor === Object) {
          if (i._stopResolving)
            return;
          for (const n in i)
            (i.component && i._uid || i.type === "link") && (this._insertRelations(
              i,
              n,
              e,
              r
            ), this._insertLinks(
              i,
              n,
              r
            )), s(i[n]);
        }
      }
    };
    s(t.content);
  }
  async resolveLinks(t, e, r) {
    let s = [];
    if (t.link_uuids) {
      const i = t.link_uuids.length, n = [], c = 50;
      for (let a = 0; a < i; a += c) {
        const l = Math.min(i, a + c);
        n.push(t.link_uuids.slice(a, l));
      }
      for (let a = 0; a < n.length; a++)
        (await this.getStories({
          per_page: c,
          language: e.language,
          version: e.version,
          by_uuids: n[a].join(",")
        })).data.stories.forEach(
          (u) => {
            s.push(u);
          }
        );
    } else
      s = t.links;
    s.forEach((i) => {
      this.links[r][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(t, e, r) {
    let s = [];
    if (t.rel_uuids) {
      const i = t.rel_uuids.length, n = [], c = 50;
      for (let a = 0; a < i; a += c) {
        const l = Math.min(i, a + c);
        n.push(t.rel_uuids.slice(a, l));
      }
      for (let a = 0; a < n.length; a++)
        (await this.getStories({
          per_page: c,
          language: e.language,
          version: e.version,
          by_uuids: n[a].join(",")
        })).data.stories.forEach((u) => {
          s.push(u);
        });
    } else
      s = t.rels;
    s && s.length > 0 && s.forEach((i) => {
      this.relations[r][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  async resolveStories(t, e, r) {
    var i, n;
    let s = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof e.resolve_relations < "u" && e.resolve_relations.length > 0 && (typeof e.resolve_relations == "string" && (s = e.resolve_relations.split(",")), await this.resolveRelations(t, e, r)), e.resolve_links && ["1", "story", "url"].indexOf(e.resolve_links) > -1 && ((i = t.links) != null && i.length || (n = t.link_uuids) != null && n.length) && await this.resolveLinks(t, e, r), this.resolveNestedRelations)
      for (const c in this.relations[r])
        this.iterateTree(
          this.relations[r][c],
          s,
          r
        );
    t.story ? this.iterateTree(t.story, s, r) : t.stories.forEach((c) => {
      this.iterateTree(c, s, r);
    }), delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(t, e, r) {
    const s = this.helpers.stringify({ url: t, params: e }), i = this.cacheProvider();
    if (this.cache.clear === "auto" && e.version === "draft" && await this.flushCache(), e.version === "published" && t != "/cdn/spaces/me") {
      const n = await i.get(s);
      if (n)
        return Promise.resolve(n);
    }
    return new Promise((n, c) => {
      try {
        (async () => {
          var a;
          try {
            const l = await this.throttle("get", t, e);
            let u = { data: l.data, headers: l.headers };
            if ((a = l.headers) != null && a["per-page"] && (u = Object.assign({}, u, {
              perPage: l.headers["per-page"] ? parseInt(l.headers["per-page"]) : 0,
              total: l.headers["per-page"] ? parseInt(l.headers.total) : 0
            })), l.status != 200)
              return c(l);
            if (u.data.story || u.data.stories) {
              const g = this.resolveCounter = ++this.resolveCounter % 1e3;
              await this.resolveStories(u.data, e, `${g}`);
            }
            return e.version === "published" && t != "/cdn/spaces/me" && await i.set(s, u), u.data.cv && e.token && (e.version == "draft" && p[e.token] != u.data.cv && await this.flushCache(), p[e.token] = u.data.cv), n(u);
          } catch (l) {
            return c(l);
          }
        })();
      } catch {
      }
    });
  }
  throttledRequest(t, e, r) {
    return this.client[t](e, r);
  }
  cacheVersions() {
    return p;
  }
  cacheVersion() {
    return p[this.accessToken];
  }
  setCacheVersion(t) {
    this.accessToken && (p[this.accessToken] = t);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(t) {
            return Promise.resolve(m[t]);
          },
          getAll() {
            return Promise.resolve(m);
          },
          set(t, e) {
            return m[t] = e, Promise.resolve(void 0);
          },
          flush() {
            return m = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve(void 0);
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this;
  }
}
export {
  _ as RichtextResolver,
  Z as RichtextSchema,
  tt as SbFetch,
  b as SbHelpers,
  rt as default
};
