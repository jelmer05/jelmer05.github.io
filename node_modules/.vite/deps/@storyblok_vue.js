import {
  createBlock,
  defineComponent,
  guardReactiveProps,
  normalizeProps,
  onMounted,
  openBlock,
  ref,
  resolveDynamicComponent
} from "./chunk-3NMN3MUW.js";

// node_modules/@storyblok/vue/dist/storyblok-vue.mjs
var U = Object.defineProperty;
var D = Object.defineProperties;
var H = Object.getOwnPropertyDescriptors;
var w = Object.getOwnPropertySymbols;
var B = Object.prototype.hasOwnProperty;
var q = Object.prototype.propertyIsEnumerable;
var T = (o, e, t) => e in o ? U(o, e, { enumerable: true, configurable: true, writable: true, value: t }) : o[e] = t;
var p = (o, e) => {
  for (var t in e || (e = {}))
    B.call(e, t) && T(o, t, e[t]);
  if (w)
    for (var t of w(e))
      q.call(e, t) && T(o, t, e[t]);
  return o;
};
var v = (o, e) => D(o, H(e));
var R = false;
var P = [];
var V = (o) => new Promise((e, t) => {
  if (typeof window > "u" || (window.storyblokRegisterEvent = (r) => {
    if (window.location === window.parent.location) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    R ? r() : P.push(r);
  }, document.getElementById("storyblok-javascript-bridge")))
    return;
  const s = document.createElement("script");
  s.async = true, s.src = o, s.id = "storyblok-javascript-bridge", s.onerror = (r) => t(r), s.onload = (r) => {
    P.forEach((n) => n()), R = true, e(r);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var z = Object.defineProperty;
var J = (o, e, t) => e in o ? z(o, e, { enumerable: true, configurable: true, writable: true, value: t }) : o[e] = t;
var c = (o, e, t) => (J(o, typeof e != "symbol" ? e + "" : e, t), t);
function E(o) {
  return !(o !== o || o === 1 / 0 || o === -1 / 0);
}
function F(o, e, t) {
  if (!E(e))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!E(t))
    throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let r = [], n = 0;
  const a = function() {
    n++;
    const l = setTimeout(function() {
      n--, s.length > 0 && a(), r = r.filter(function(u) {
        return u !== l;
      });
    }, t);
    r.indexOf(l) < 0 && r.push(l);
    const h = s.shift();
    h.resolve(o.apply(h.self, h.args));
  }, i = function(...l) {
    const h = this;
    return new Promise(function(u, b) {
      s.push({
        resolve: u,
        reject: b,
        args: l,
        self: h
      }), n < e && a();
    });
  };
  return i.abort = function() {
    r.forEach(clearTimeout), r = [], s.forEach(function(l) {
      l.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), s.length = 0;
  }, i;
}
var G = function(o, e) {
  const t = {};
  for (const s in o) {
    const r = o[s];
    e.indexOf(s) > -1 && r !== null && (t[s] = r);
  }
  return t;
};
var Y = (o) => o === "email";
var K = () => ({
  singleTag: "hr"
});
var Q = () => ({
  tag: "blockquote"
});
var W = () => ({
  tag: "ul"
});
var X = (o) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: o.attrs
    }
  ]
});
var Z = () => ({
  singleTag: "br"
});
var ee = (o) => ({
  tag: `h${o.attrs.level}`
});
var te = (o) => ({
  singleTag: [
    {
      tag: "img",
      attrs: G(o.attrs, ["src", "alt", "title"])
    }
  ]
});
var se = () => ({
  tag: "li"
});
var re = () => ({
  tag: "ol"
});
var oe = () => ({
  tag: "p"
});
var ne = () => ({
  tag: "b"
});
var ie = () => ({
  tag: "strike"
});
var ae = () => ({
  tag: "u"
});
var le = () => ({
  tag: "strong"
});
var ce = () => ({
  tag: "code"
});
var he = () => ({
  tag: "i"
});
var ue = (o) => {
  const e = p({}, o.attrs), { linktype: t = "url" } = o.attrs;
  return Y(t) && (e.href = `mailto:${e.href}`), e.anchor && (e.href = `${e.href}#${e.anchor}`, delete e.anchor), {
    tag: [
      {
        tag: "a",
        attrs: e
      }
    ]
  };
};
var pe = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
});
var de = {
  nodes: {
    horizontal_rule: K,
    blockquote: Q,
    bullet_list: W,
    code_block: X,
    hard_break: Z,
    heading: ee,
    image: te,
    list_item: se,
    ordered_list: re,
    paragraph: oe
  },
  marks: {
    bold: ne,
    strike: ie,
    underline: ae,
    strong: le,
    code: ce,
    italic: he,
    link: ue,
    styled: pe
  }
};
var ge = function(o) {
  const e = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, t = /[&<>"']/g, s = RegExp(t.source);
  return o && s.test(o) ? o.replace(t, (r) => e[r]) : o;
};
var y = class {
  constructor(e) {
    c(this, "marks"), c(this, "nodes"), e || (e = de), this.marks = e.marks || [], this.nodes = e.nodes || [];
  }
  addNode(e, t) {
    this.nodes[e] = t;
  }
  addMark(e, t) {
    this.marks[e] = t;
  }
  render(e) {
    if (e && e.content && Array.isArray(e.content)) {
      let t = "";
      return e.content.forEach((s) => {
        t += this.renderNode(s);
      }), t;
    }
    return console.warn("The render method must receive an object with a content field, which is an array"), "";
  }
  renderNode(e) {
    const t = [];
    e.marks && e.marks.forEach((r) => {
      const n = this.getMatchingMark(r);
      n && t.push(this.renderOpeningTag(n.tag));
    });
    const s = this.getMatchingNode(e);
    return s && s.tag && t.push(this.renderOpeningTag(s.tag)), e.content ? e.content.forEach((r) => {
      t.push(this.renderNode(r));
    }) : e.text ? t.push(ge(e.text)) : s && s.singleTag ? t.push(this.renderTag(s.singleTag, " /")) : s && s.html && t.push(s.html), s && s.tag && t.push(this.renderClosingTag(s.tag)), e.marks && e.marks.slice(0).reverse().forEach((r) => {
      const n = this.getMatchingMark(r);
      n && t.push(this.renderClosingTag(n.tag));
    }), t.join("");
  }
  renderTag(e, t) {
    return e.constructor === String ? `<${e}${t}>` : e.map((s) => {
      if (s.constructor === String)
        return `<${s}${t}>`;
      {
        let r = `<${s.tag}`;
        if (s.attrs)
          for (const n in s.attrs) {
            const a = s.attrs[n];
            a !== null && (r += ` ${n}="${a}"`);
          }
        return `${r}${t}>`;
      }
    }).join("");
  }
  renderOpeningTag(e) {
    return this.renderTag(e, "");
  }
  renderClosingTag(e) {
    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((t) => t.constructor === String ? `</${t}>` : `</${t.tag}>`).join("");
  }
  getMatchingNode(e) {
    const t = this.nodes[e.type];
    if (typeof t == "function")
      return t(e);
  }
  getMatchingMark(e) {
    const t = this.marks[e.type];
    if (typeof t == "function")
      return t(e);
  }
};
var O = class {
  constructor() {
    c(this, "isCDNUrl", (e = "") => e.indexOf("/cdn/") > -1), c(this, "getOptionsPage", (e, t = 25, s = 1) => v(p({}, e), {
      per_page: t,
      page: s
    })), c(this, "delay", (e) => new Promise((t) => setTimeout(t, e))), c(this, "arrayFrom", (e = 0, t) => [...Array(e)].map(t)), c(this, "range", (e = 0, t = e) => {
      const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;
      return this.arrayFrom(s, (n, a) => a * r + e);
    }), c(this, "asyncMap", async (e, t) => Promise.all(e.map(t))), c(this, "flatMap", (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], []));
  }
  stringify(e, t, s) {
    const r = [];
    for (const n in e) {
      if (!Object.prototype.hasOwnProperty.call(e, n))
        continue;
      const a = e[n], i = s ? "" : encodeURIComponent(n);
      let l;
      typeof a == "object" ? l = this.stringify(a, t ? t + encodeURIComponent("[" + i + "]") : i, Array.isArray(a)) : l = (t ? t + encodeURIComponent("[" + i + "]") : i) + "=" + encodeURIComponent(a), r.push(l);
    }
    return r.join("&");
  }
};
var g = ((o) => (o.GET = "get", o.DELETE = "delete", o.POST = "post", o.PUT = "put", o))(g || {});
var fe = class {
  constructor(e) {
    c(this, "baseURL"), c(this, "timeout"), c(this, "headers"), c(this, "responseInterceptor"), c(this, "ejectInterceptor"), c(this, "url"), c(this, "parameters"), this.baseURL = e.baseURL, this.timeout = e.timeout ? e.timeout * 1e3 : 1e3, this.headers = e.headers || [], this.responseInterceptor = e.responseInterceptor, this.ejectInterceptor = false, this.url = "", this.parameters = {};
  }
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler(g.GET);
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler(g.POST);
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler(g.PUT);
  }
  delete(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler(g.DELETE);
  }
  async _responseHandler(e) {
    const t = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    await e.json().then((r) => {
      s.data = r;
    });
    for (const r of e.headers.entries())
      t[r[0]] = r[1];
    return s.headers = p({}, t), s.status = e.status, s.statusText = e.statusText, s;
  }
  async _methodHandler(e) {
    const t = new URL(`${this.baseURL}${this.url}`);
    let s = null;
    if (e === "get") {
      const i = new O();
      t.search = i.stringify(this.parameters);
    } else
      s = JSON.stringify(this.parameters);
    const r = new AbortController(), { signal: n } = r, a = setTimeout(() => r.abort(), this.timeout);
    try {
      const i = await fetch(`${t}`, {
        method: e,
        headers: this.headers,
        body: s,
        signal: n
      });
      clearTimeout(a);
      const l = await this._responseHandler(i);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(l)) : this._statusHandler(l);
    } catch (i) {
      return i;
    }
  }
  eject() {
    this.ejectInterceptor = true;
  }
  _statusHandler(e) {
    if (/20[01]/g.test(`${e.status}`))
      return e;
    throw {
      message: new Error(e.statusText || `status: ${e.status}`),
      response: e
    };
  }
};
var m = {};
var d = {};
var me = class {
  constructor(e, t) {
    if (c(this, "client"), c(this, "maxRetries"), c(this, "throttle"), c(this, "accessToken"), c(this, "cache"), c(this, "helpers"), c(this, "relations"), c(this, "links"), c(this, "richTextResolver"), c(this, "resolveNestedRelations"), !t) {
      const n = e.region ? `-${e.region}` : "", a = e.https === false ? "http" : "https";
      e.oauthToken ? t = `${a}://api${n}.storyblok.com/v1` : t = `${a}://api${n}.storyblok.com/v2`;
    }
    const s = Object.assign({}, e.headers);
    let r = 5;
    e.oauthToken && (s.Authorization = e.oauthToken, r = 3), e.rateLimit && (r = e.rateLimit), e.richTextSchema ? this.richTextResolver = new y(e.richTextSchema) : this.richTextResolver = new y(), e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries, this.throttle = F(this.throttledRequest, r, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.helpers = new O(), this.resolveNestedRelations = false, this.client = new fe({
      baseURL: t,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor
    });
  }
  setComponentResolver(e) {
    this.richTextResolver.addNode("blok", (t) => {
      let s = "";
      return t.attrs.body.forEach((r) => {
        s += e(r.component, r);
      }), {
        html: s
      };
    });
  }
  parseParams(e) {
    return e.version || (e.version = "published"), e.token || (e.token = this.getToken()), e.cv || (e.cv = d[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), e;
  }
  factoryParamOptions(e, t) {
    return this.helpers.isCDNUrl(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, s, r) {
    const n = this.factoryParamOptions(e, this.helpers.getOptionsPage(t, s, r));
    return this.cacheResponse(e, n);
  }
  get(e, t) {
    t || (t = {});
    const s = `/${e}`, r = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, r);
  }
  async getAll(e, t, s) {
    const r = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`, a = n.split("/"), i = s || a[a.length - 1], l = 1, h = await this.makeRequest(n, t, r, l), u = h.total ? Math.ceil(h.total / r) : 1, b = await this.helpers.asyncMap(this.helpers.range(l, u), (k) => this.makeRequest(n, t, r, k + 1));
    return this.helpers.flatMap([h, ...b], (k) => Object.values(k.data[i]));
  }
  post(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("post", s, t));
  }
  put(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("put", s, t));
  }
  delete(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("delete", s, t));
  }
  getStories(e) {
    return this.get("cdn/stories", e);
  }
  getStory(e, t) {
    return this.get(`cdn/stories/${e}`, t);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t) {
    const s = e[t];
    s && s.fieldtype == "multilink" && s.linktype == "story" && typeof s.id == "string" && this.links[s.id] ? s.story = this._cleanCopy(this.links[s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[s.uuid] && (s.story = this._cleanCopy(this.links[s.uuid]));
  }
  _insertRelations(e, t, s) {
    if (s.indexOf(`${e.component}.${t}`) > -1) {
      if (typeof e[t] == "string")
        this.relations[e[t]] && (e[t] = this._cleanCopy(this.relations[e[t]]));
      else if (e[t] && e[t].constructor === Array) {
        const r = [];
        e[t].forEach((n) => {
          this.relations[n] && r.push(this._cleanCopy(this.relations[n]));
        }), e[t] = r;
      }
    }
  }
  iterateTree(e, t) {
    const s = (r) => {
      if (r != null) {
        if (r.constructor === Array)
          for (let n = 0; n < r.length; n++)
            s(r[n]);
        else if (r.constructor === Object) {
          if (r._stopResolving)
            return;
          for (const n in r)
            (r.component && r._uid || r.type === "link") && (this._insertRelations(r, n, t), this._insertLinks(r, n)), s(r[n]);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t) {
    let s = [];
    if (e.link_uuids) {
      const r = e.link_uuids.length, n = [], a = 50;
      for (let i = 0; i < r; i += a) {
        const l = Math.min(r, i + a);
        n.push(e.link_uuids.slice(i, l));
      }
      for (let i = 0; i < n.length; i++)
        (await this.getStories({
          per_page: a,
          language: t.language,
          version: t.version,
          by_uuids: n[i].join(",")
        })).data.stories.forEach((l) => {
          s.push(l);
        });
    } else
      s = e.links;
    s.forEach((r) => {
      this.links[r.uuid] = v(p({}, r), { _stopResolving: true });
    });
  }
  async resolveRelations(e, t) {
    let s = [];
    if (e.rel_uuids) {
      const r = e.rel_uuids.length, n = [], a = 50;
      for (let i = 0; i < r; i += a) {
        const l = Math.min(r, i + a);
        n.push(e.rel_uuids.slice(i, l));
      }
      for (let i = 0; i < n.length; i++)
        (await this.getStories({
          per_page: a,
          language: t.language,
          version: t.version,
          by_uuids: n[i].join(",")
        })).data.stories.forEach((l) => {
          s.push(l);
        });
    } else
      s = e.rels;
    s && s.length > 0 && s.forEach((r) => {
      this.relations[r.uuid] = v(p({}, r), { _stopResolving: true });
    });
  }
  async resolveStories(e, t) {
    var s, r;
    let n = [];
    if (typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (n = t.resolve_relations.split(","), await this.resolveRelations(e, t)), t.resolve_links && ["1", "story", "url"].indexOf(t.resolve_links) > -1 && (((s = e.links) == null ? void 0 : s.length) || ((r = e.link_uuids) == null ? void 0 : r.length)) && await this.resolveLinks(e, t), this.resolveNestedRelations)
      for (const a in this.relations)
        this.iterateTree(this.relations[a], n);
    e.story ? this.iterateTree(e.story, n) : e.stories.forEach((a) => {
      this.iterateTree(a, n);
    });
  }
  cacheResponse(e, t, s) {
    return new Promise((r, n) => {
      const a = this.helpers.stringify({ url: e, params: t }), i = this.cacheProvider();
      if (this.cache.clear === "auto" && t.version === "draft" && this.flushCache(), t.version === "published" && e != "/cdn/spaces/me") {
        const l = i.get(a);
        if (l)
          return r(l);
      }
      try {
        (async () => {
          var l;
          const h = await this.throttle("get", e, t);
          let u = { data: h.data, headers: h.headers };
          if ((l = h.headers) != null && l["per-page"] && (u = Object.assign({}, u, {
            perPage: h.headers["per-page"] ? parseInt(h.headers["per-page"]) : 0,
            total: h.headers["per-page"] ? parseInt(h.headers.total) : 0
          })), h.status != 200)
            return n(h);
          (u.data.story || u.data.stories) && await this.resolveStories(u.data, t), t.version === "published" && e != "/cdn/spaces/me" && i.set(a, u), u.data.cv && t.token && (t.version == "draft" && d[t.token] != u.data.cv && this.flushCache(), d[t.token] = u.data.cv), r(u);
        })();
      } catch {
      }
    });
  }
  throttledRequest(e, t, s) {
    return this.client[e](t, s);
  }
  cacheVersions() {
    return d;
  }
  cacheVersion() {
    return d[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (d[this.accessToken] = e);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return m[e];
          },
          getAll() {
            return m;
          },
          set(e, t) {
            m[e] = t;
          },
          flush() {
            m = {};
          }
        };
      default:
        return {
          get() {
          },
          getAll() {
          },
          set() {
          },
          flush() {
          }
        };
    }
  }
  flushCache() {
    return this.cacheProvider().flush(), this;
  }
};
var Re = (o = {}) => {
  const { apiOptions: e } = o;
  if (!e.accessToken) {
    console.error("You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication");
    return;
  }
  return { storyblokApi: new me(e) };
};
var ye = (o) => {
  if (typeof o != "object" || typeof o._editable > "u")
    return {};
  const e = JSON.parse(o._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, ""));
  return {
    "data-blok-c": JSON.stringify(e),
    "data-blok-uid": e.id + "-" + e.uid
  };
};
var _;
var be = "https://app.storyblok.com/f/storyblok-v2-latest.js";
var ke = (o, e, t = {}) => {
  if (!(typeof window > "u")) {
    if (typeof window.storyblokRegisterEvent > "u") {
      console.error("Storyblok Bridge is disabled. Please enable it to use it. Read https://github.com/storyblok/storyblok-js");
      return;
    }
    if (!o) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(t).on(["input", "published", "change"], (r) => {
        r.action === "input" && r.story.id === o ? e(r.story) : (r.action === "change" || r.action === "published") && r.storyId === o && window.location.reload();
      });
    });
  }
};
var ve = (o = {}) => {
  const {
    bridge: e,
    accessToken: t,
    use: s = [],
    apiOptions: r = {},
    richText: n = {}
  } = o;
  r.accessToken = r.accessToken || t;
  const a = { bridge: e, apiOptions: r };
  let i = {};
  return s.forEach((l) => {
    i = p(p({}, i), l(a));
  }), e !== false && V(be), _ = new y(n.schema), n.resolver && $(_, n.resolver), i;
};
var $ = (o, e) => {
  o.addNode("blok", (t) => {
    let s = "";
    return t.attrs.body.forEach((r) => {
      s += e(r.component, r);
    }), {
      html: s
    };
  });
};
var Pe = (o, e, t) => {
  let s = t || _;
  if (!s) {
    console.error("Please initialize the Storyblok SDK before calling the renderRichText function");
    return;
  }
  return o === "" ? "" : o ? (e && (s = new y(e.schema), e.resolver && $(s, e.resolver)), s.render(o)) : (console.warn(`${o} is not a valid Richtext object. This might be because the value of the richtext field is empty.
    
  For more info about the richtext object check https://github.com/storyblok/storyblok-js#rendering-rich-text`), "");
};
var _e = defineComponent({
  __name: "StoryblokComponent",
  props: {
    blok: null
  },
  setup(o) {
    return (e, t) => (openBlock(), createBlock(resolveDynamicComponent(o.blok.component), normalizeProps(guardReactiveProps({ ...e.$props, ...e.$attrs })), null, 16));
  }
});
var we = {
  beforeMount(o, e) {
    if (e.value) {
      const t = ye(e.value);
      o.setAttribute("data-blok-c", t["data-blok-c"]), o.setAttribute("data-blok-uid", t["data-blok-uid"]), o.classList.add("storyblok__outline");
    }
  }
};
var S = (o) => {
  console.error(`You can't use ${o} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
var f = null;
var Ee = () => (f || S("useStoryblokApi"), f);
var Oe = async (o, e = {}, t = {}) => {
  const s = ref(null);
  if (onMounted(() => {
    s.value && s.value.id && ke(
      s.value.id,
      (r) => s.value = r,
      t
    );
  }), f) {
    const { data: r } = await f.get(
      `cdn/stories/${o}`,
      e
    );
    s.value = r.story;
  } else
    S("useStoryblok");
  return s;
};
var $e = {
  install(o, e = {}) {
    o.directive("editable", we), o.component("StoryblokComponent", _e);
    const { storyblokApi: t } = ve(e);
    f = t;
  }
};
export {
  y as RichTextResolver,
  de as RichTextSchema,
  _e as StoryblokComponent,
  $e as StoryblokVue,
  Re as apiPlugin,
  Pe as renderRichText,
  Oe as useStoryblok,
  Ee as useStoryblokApi,
  ke as useStoryblokBridge
};
//# sourceMappingURL=@storyblok_vue.js.map
