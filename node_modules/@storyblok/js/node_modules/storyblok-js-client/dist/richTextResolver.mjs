var b = Object.defineProperty;
var $ = (s, e, t) => e in s ? b(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var l = (s, e, t) => ($(s, typeof e != "symbol" ? e + "" : e, t), t);
class k {
  constructor() {
    l(this, "isCDNUrl", (e = "") => e.indexOf("/cdn/") > -1);
    l(this, "getOptionsPage", (e, t = 25, r = 1) => ({
      ...e,
      per_page: t,
      page: r
    }));
    l(this, "delay", (e) => new Promise((t) => setTimeout(t, e)));
    l(this, "arrayFrom", (e = 0, t) => [...Array(e)].map(t));
    l(this, "range", (e = 0, t = e) => {
      const r = Math.abs(t - e) || 0, n = e < t ? 1 : -1;
      return this.arrayFrom(r, (a, i) => i * n + e);
    });
    l(this, "asyncMap", async (e, t) => Promise.all(e.map(t)));
    l(this, "flatMap", (e = [], t) => e.map(t).reduce((r, n) => [...r, ...n], []));
    /**
     * @method escapeHTML
     * @param  {String} string text to be parsed
     * @return {String} Text parsed
     */
    l(this, "escapeHTML", function(e) {
      const t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, r = /[&<>"']/g, n = RegExp(r.source);
      return e && n.test(e) ? e.replace(r, (a) => t[a]) : e;
    });
  }
  /**
   * @method stringify
   * @param  {Object} params
   * @param  {String} prefix
   * @param  {Boolean} isArray
   * @return {String} Stringified object
   */
  stringify(e, t, r) {
    const n = [];
    for (const a in e) {
      if (!Object.prototype.hasOwnProperty.call(e, a))
        continue;
      const i = e[a], o = r ? "" : encodeURIComponent(a);
      let g;
      typeof i == "object" ? g = this.stringify(
        i,
        t ? t + encodeURIComponent("[" + o + "]") : o,
        Array.isArray(i)
      ) : g = (t ? t + encodeURIComponent("[" + o + "]") : o) + "=" + encodeURIComponent(i), n.push(g);
    }
    return n.join("&");
  }
  /**
   * @method getRegionURL
   * @param  {String} regionCode region code, could be eu, us or cn
   * @return {String} The base URL of the region
   */
  getRegionURL(e) {
    const t = "api.storyblok.com", r = "api-us.storyblok.com", n = "app.storyblokchina.cn";
    switch (e) {
      case "us":
        return r;
      case "cn":
        return n;
      default:
        return t;
    }
  }
}
const j = function(s, e) {
  const t = {};
  for (const r in s) {
    const n = s[r];
    e.indexOf(r) > -1 && n !== null && (t[r] = n);
  }
  return t;
}, T = (s) => s === "email", I = () => ({
  singleTag: "hr"
}), x = () => ({
  tag: "blockquote"
}), R = () => ({
  tag: "ul"
}), w = (s) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: s.attrs
    }
  ]
}), M = () => ({
  singleTag: "br"
}), z = (s) => ({
  tag: `h${s.attrs.level}`
}), U = (s) => ({
  singleTag: [
    {
      tag: "img",
      attrs: j(s.attrs, ["src", "alt", "title"])
    }
  ]
}), _ = () => ({
  tag: "li"
}), E = () => ({
  tag: "ol"
}), H = () => ({
  tag: "p"
}), A = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: {
        "data-type": "emoji",
        "data-name": s.attrs.name,
        emoji: s.attrs.emoji
      }
    }
  ]
}), S = () => ({
  tag: "b"
}), C = () => ({
  tag: "strike"
}), q = () => ({
  tag: "u"
}), L = () => ({
  tag: "strong"
}), O = () => ({
  tag: "code"
}), N = () => ({
  tag: "i"
}), P = (s) => {
  if (!s.attrs)
    return {
      tag: ""
    };
  const e = new k().escapeHTML, t = { ...s.attrs }, { linktype: r = "url" } = s.attrs;
  if (delete t.linktype, t.href && (t.href = e(s.attrs.href || "")), T(r) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {
    for (const n in t.custom)
      t[n] = t.custom[n];
    delete t.custom;
  }
  return {
    tag: [
      {
        tag: "a",
        attrs: t
      }
    ]
  };
}, F = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: s.attrs
    }
  ]
}), D = () => ({
  tag: "sub"
}), W = () => ({
  tag: "sup"
}), B = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: s.attrs
    }
  ]
}), G = (s) => {
  var t;
  return (t = s.attrs) != null && t.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `background-color:${s.attrs.color};`
        }
      }
    ]
  } : {
    tag: ""
  };
}, J = (s) => {
  var t;
  return (t = s.attrs) != null && t.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `color:${s.attrs.color}`
        }
      }
    ]
  } : {
    tag: ""
  };
}, K = {
  nodes: {
    horizontal_rule: I,
    blockquote: x,
    bullet_list: R,
    code_block: w,
    hard_break: M,
    heading: z,
    image: U,
    list_item: _,
    ordered_list: E,
    paragraph: H,
    emoji: A
  },
  marks: {
    bold: S,
    strike: C,
    underline: q,
    strong: L,
    code: O,
    italic: N,
    link: P,
    styled: F,
    subscript: D,
    superscript: W,
    anchor: B,
    highlight: G,
    textStyle: J
  }
}, Q = function(s) {
  const e = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, t = /[&<>"']/g, r = RegExp(t.source);
  return s && r.test(s) ? s.replace(t, (n) => e[n]) : s;
};
class X {
  constructor(e) {
    l(this, "marks");
    l(this, "nodes");
    e || (e = K), this.marks = e.marks || [], this.nodes = e.nodes || [];
  }
  addNode(e, t) {
    this.nodes[e] = t;
  }
  addMark(e, t) {
    this.marks[e] = t;
  }
  render(e, t = { optimizeImages: !1 }) {
    if (e && e.content && Array.isArray(e.content)) {
      let r = "";
      return e.content.forEach((n) => {
        r += this.renderNode(n);
      }), t.optimizeImages ? this.optimizeImages(r, t.optimizeImages) : r;
    }
    return console.warn(
      `The render method must receive an Object with a "content" field.
			The "content" field must be an array of nodes as the type ISbRichtext.
			ISbRichtext:
				content?: ISbRichtext[]
				marks?: ISbRichtext[]
				attrs?: any
				text?: string
				type: string
				
				Example:
				{
					content: [
						{
							content: [
								{
									text: 'Hello World',
									type: 'text'
								}
							],
							type: 'paragraph'
						}
					],
					type: 'doc'
				}`
    ), "";
  }
  optimizeImages(e, t) {
    let r = 0, n = 0, a = "", i = "";
    typeof t != "boolean" && (typeof t.width == "number" && t.width > 0 && (a += `width="${t.width}" `, r = t.width), typeof t.height == "number" && t.height > 0 && (a += `height="${t.height}" `, n = t.height), (t.loading === "lazy" || t.loading === "eager") && (a += `loading="${t.loading}" `), typeof t.class == "string" && t.class.length > 0 && (a += `class="${t.class}" `), t.filters && (typeof t.filters.blur == "number" && t.filters.blur >= 0 && t.filters.blur <= 100 && (i += `:blur(${t.filters.blur})`), typeof t.filters.brightness == "number" && t.filters.brightness >= -100 && t.filters.brightness <= 100 && (i += `:brightness(${t.filters.brightness})`), t.filters.fill && (t.filters.fill.match(/[0-9A-Fa-f]{6}/g) || t.filters.fill === "transparent") && (i += `:fill(${t.filters.fill})`), t.filters.format && ["webp", "png", "jpeg"].includes(t.filters.format) && (i += `:format(${t.filters.format})`), typeof t.filters.grayscale == "boolean" && t.filters.grayscale && (i += ":grayscale()"), typeof t.filters.quality == "number" && t.filters.quality >= 0 && t.filters.quality <= 100 && (i += `:quality(${t.filters.quality})`), t.filters.rotate && [90, 180, 270].includes(t.filters.rotate) && (i += `:rotate(${t.filters.rotate})`), i.length > 0 && (i = "/filters" + i))), a.length > 0 && (e = e.replace(/<img/g, `<img ${a.trim()}`));
    const o = r > 0 || n > 0 || i.length > 0 ? `${r}x${n}${i}` : "";
    return e = e.replace(
      /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,
      `a.storyblok.com/f/$1/$2.$3/m/${o}`
    ), typeof t != "boolean" && (t.sizes || t.srcset) && (e = e.replace(/<img.*?src=["|'](.*?)["|']/g, (g) => {
      var d, p;
      const f = g.match(
        /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g
      );
      if (f && f.length > 0) {
        const u = {
          srcset: (d = t.srcset) == null ? void 0 : d.map((c) => {
            if (typeof c == "number")
              return `//${f}/m/${c}x0${i} ${c}w`;
            if (typeof c == "object" && c.length === 2) {
              let m = 0, y = 0;
              return typeof c[0] == "number" && (m = c[0]), typeof c[1] == "number" && (y = c[1]), `//${f}/m/${m}x${y}${i} ${m}w`;
            }
          }).join(", "),
          sizes: (p = t.sizes) == null ? void 0 : p.map((c) => c).join(", ")
        };
        let h = "";
        return u.srcset && (h += `srcset="${u.srcset}" `), u.sizes && (h += `sizes="${u.sizes}" `), g.replace(/<img/g, `<img ${h.trim()}`);
      }
      return g;
    })), e;
  }
  renderNode(e) {
    const t = [];
    e.marks && e.marks.forEach((n) => {
      const a = this.getMatchingMark(n);
      a && a.tag !== "" && t.push(this.renderOpeningTag(a.tag));
    });
    const r = this.getMatchingNode(e);
    return r && r.tag && t.push(this.renderOpeningTag(r.tag)), e.content ? e.content.forEach((n) => {
      t.push(this.renderNode(n));
    }) : e.text ? t.push(Q(e.text)) : r && r.singleTag ? t.push(this.renderTag(r.singleTag, " /")) : r && r.html ? t.push(r.html) : e.type === "emoji" && t.push(this.renderEmoji(e)), r && r.tag && t.push(this.renderClosingTag(r.tag)), e.marks && e.marks.slice(0).reverse().forEach((n) => {
      const a = this.getMatchingMark(n);
      a && a.tag !== "" && t.push(this.renderClosingTag(a.tag));
    }), t.join("");
  }
  renderTag(e, t) {
    return e.constructor === String ? `<${e}${t}>` : e.map((n) => {
      if (n.constructor === String)
        return `<${n}${t}>`;
      {
        let a = `<${n.tag}`;
        if (n.attrs)
          for (const i in n.attrs) {
            const o = n.attrs[i];
            o !== null && (a += ` ${i}="${o}"`);
          }
        return `${a}${t}>`;
      }
    }).join("");
  }
  renderOpeningTag(e) {
    return this.renderTag(e, "");
  }
  renderClosingTag(e) {
    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((r) => r.constructor === String ? `</${r}>` : `</${r.tag}>`).join("");
  }
  getMatchingNode(e) {
    const t = this.nodes[e.type];
    if (typeof t == "function")
      return t(e);
  }
  getMatchingMark(e) {
    const t = this.marks[e.type];
    if (typeof t == "function")
      return t(e);
  }
  renderEmoji(e) {
    if (e.attrs.emoji)
      return e.attrs.emoji;
    const t = [
      {
        tag: "img",
        attrs: {
          src: e.attrs.fallbackImage,
          draggable: "false",
          loading: "lazy",
          align: "absmiddle"
        }
      }
    ];
    return this.renderTag(t, " /");
  }
}
export {
  X as default
};
