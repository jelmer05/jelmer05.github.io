/**
 * name: @storyblok/js
 * (c) 2026
 * description: SDK to integrate Storyblok into your project using JavaScript.
 * author: undefined
 */
var le = Object.defineProperty;
var ce = (e, t, r) => t in e ? le(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var y = (e, t, r) => ce(e, typeof t != "symbol" ? t + "" : t, r);
let E = /* @__PURE__ */ function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
}({}), w = /* @__PURE__ */ function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
}({}), ue = /* @__PURE__ */ function(e) {
  return e.TEXT = "text", e;
}({}), x = /* @__PURE__ */ function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
}({});
const he = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], de = (e = {}) => {
  const { custom: t, ...r } = e, s = {
    ...r,
    ...t
  };
  return Object.keys(s).map((i) => `${i}="${s[i]}"`).join(" ");
}, fe = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function ge(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const O = (e) => Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== void 0));
function ye(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let r = 0, s = 0;
  const i = {}, n = [];
  function l(u, c, b, m, R) {
    typeof u != "number" || u <= c || u >= b ? console.warn(`[StoryblokRichText] - ${m.charAt(0).toUpperCase() + m.slice(1)} value must be a number between ${c} and ${b} (inclusive)`) : R.push(`${m}(${u})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (i.width = t.width, r = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (i.height = t.height, s = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete i.width, delete i.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (i.loading = t.loading), t.class && (i.class = t.class), t.filters) {
      const { filters: u } = t || {}, { blur: c, brightness: b, fill: m, format: R, grayscale: A, quality: _, rotate: T } = u || {};
      c && l(c, 0, 100, "blur", n), _ && l(_, 0, 100, "quality", n), b && l(b, 0, 100, "brightness", n), m && n.push(`fill(${m})`), A && n.push("grayscale()"), T && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && n.push(`rotate(${T})`), R && [
        "webp",
        "png",
        "jpeg"
      ].includes(R) && n.push(`format(${R})`);
    }
    t.srcset && (i.srcset = t.srcset.map((u) => {
      if (typeof u == "number") return `${e}/m/${u}x0/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${u}w`;
      if (Array.isArray(u) && u.length === 2) {
        const [c, b] = u;
        return `${e}/m/${c}x${b}/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${c}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (i.sizes = t.sizes.join(", "));
  }
  let a = `${e}/m/`;
  return (r > 0 || s > 0) && (a = `${a}${r}x${s}/`), n.length > 0 && (a = `${a}filters:${n.join(":")}`), {
    src: a,
    attrs: i
  };
}
function Y(e, t = {}, r) {
  const s = de(t), i = s ? `${e} ${s}` : e, n = Array.isArray(r) ? r.join("") : r || "";
  if (e) {
    if (he.includes(e)) return `<${i}>`;
  } else return n;
  return `<${i}>${n}</${e}>`;
}
function be(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: r = Y, textFn: s = ge, resolvers: i = {}, optimizeImages: n = !1, keyedResolvers: l = !1 } = e, a = r !== Y, u = (o = {}) => {
    const { textAlign: h, class: d, id: f, style: g, ...v } = o, p = [];
    return g && p.push(g.endsWith(";") ? g : `${g};`), h && p.push(`text-align: ${h};`), O({
      ...v,
      class: d,
      id: f,
      ...p.length > 0 ? { style: p.join(" ") } : {}
    });
  }, c = (o) => (h, d) => {
    const f = u(h.attrs);
    return d.render(o, f, h.children || null);
  }, b = (o, h) => {
    const { src: d, alt: f, title: g, srcset: v, sizes: p } = o.attrs || {};
    let k = d, L = {};
    if (n) {
      const { src: oe, attrs: ae } = ye(d, n);
      k = oe, L = ae;
    }
    const I = {
      src: k,
      alt: f,
      title: g,
      srcset: v,
      sizes: p,
      ...L
    };
    return h.render("img", O(I));
  }, m = (o, h) => {
    const { level: d, ...f } = o.attrs || {}, g = u(f);
    return h.render(`h${d}`, g, o.children);
  }, R = (o, h) => {
    var f, g, v, p;
    const d = h.render("img", {
      src: (f = o.attrs) == null ? void 0 : f.fallbackImage,
      alt: (g = o.attrs) == null ? void 0 : g.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h.render("span", {
      "data-type": "emoji",
      "data-name": (v = o.attrs) == null ? void 0 : v.name,
      "data-emoji": (p = o.attrs) == null ? void 0 : p.emoji
    }, d);
  }, A = (o, h) => h.render("pre", o.attrs || {}, h.render("code", {}, o.children || "")), _ = (o, h = !1) => ({ text: d, attrs: f }, g) => {
    const { class: v, id: p, ...k } = f || {}, L = h ? {
      class: v,
      id: p,
      style: fe(k) || void 0
    } : f || {};
    return g.render(o, O(L), d);
  }, T = (o) => U(o), H = (o) => {
    const { marks: h, ...d } = o;
    if ("text" in o) {
      if (h) return h.reduce((g, v) => T({
        ...v,
        text: g
      }), T({
        ...d,
        children: d.children
      }));
      const f = o.attrs || {};
      if (l) {
        const g = t.get("txt") || 0;
        t.set("txt", g + 1), f.key = `txt-${g}`;
      }
      return s(d.text, f);
    }
    return "";
  }, z = (o, h) => {
    const { linktype: d, href: f, anchor: g, ...v } = o.attrs || {};
    let p = "";
    switch (d) {
      case x.ASSET:
      case x.URL:
        p = f;
        break;
      case x.EMAIL:
        p = `mailto:${f}`;
        break;
      case x.STORY:
        p = f, g && (p = `${p}#${g}`);
        break;
      default:
        p = f;
        break;
    }
    const k = { ...v };
    return p && (k.href = p), h.render("a", k, o.text);
  }, ee = (o, h) => {
    var d, f;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h.render("span", {
      blok: (d = o == null ? void 0 : o.attrs) == null ? void 0 : d.body[0],
      id: (f = o.attrs) == null ? void 0 : f.id,
      style: "display: none"
    });
  }, te = (o, h) => {
    const d = u(o.attrs), f = o.children || null;
    return h.render("table", d, h.render("tbody", {}, f));
  }, re = (o, h) => {
    const d = u(o.attrs);
    return h.render("tr", d, o.children);
  }, se = (o, h) => {
    const { colspan: d, rowspan: f, colwidth: g, backgroundColor: v, textAlign: p, ...k } = o.attrs || {}, L = [];
    g && L.push(`width: ${g}px;`), v && L.push(`background-color: ${v};`), p && L.push(`text-align: ${p};`);
    const I = {
      ...k,
      ...d > 1 ? { colspan: d } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...L.length > 0 ? { style: L.join(" ") } : {}
    };
    return h.render("td", O(I), o.children);
  }, ie = (o, h) => {
    const { colspan: d, rowspan: f, colwidth: g, backgroundColor: v, textAlign: p, ...k } = o.attrs || {}, L = [];
    g && L.push(`width: ${g}px;`), v && L.push(`background-color: ${v};`), p && L.push(`text-align: ${p};`);
    const I = {
      ...k,
      ...d > 1 ? { colspan: d } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...L.length > 0 ? { style: L.join(" ") } : {}
    };
    return h.render("th", O(I), o.children);
  }, D = /* @__PURE__ */ new Map([
    [E.DOCUMENT, c("")],
    [E.HEADING, m],
    [E.PARAGRAPH, c("p")],
    [E.UL_LIST, c("ul")],
    [E.OL_LIST, c("ol")],
    [E.LIST_ITEM, c("li")],
    [E.IMAGE, b],
    [E.EMOJI, R],
    [E.CODE_BLOCK, A],
    [E.HR, c("hr")],
    [E.BR, c("br")],
    [E.QUOTE, c("blockquote")],
    [E.COMPONENT, ee],
    [ue.TEXT, H],
    [w.LINK, z],
    [w.ANCHOR, z],
    [w.STYLED, _("span", !0)],
    [w.BOLD, _("strong")],
    [w.TEXT_STYLE, _("span", !0)],
    [w.ITALIC, _("em")],
    [w.UNDERLINE, _("u")],
    [w.STRIKE, _("s")],
    [w.CODE, _("code")],
    [w.SUPERSCRIPT, _("sup")],
    [w.SUBSCRIPT, _("sub")],
    [w.HIGHLIGHT, _("mark")],
    [E.TABLE, te],
    [E.TABLE_ROW, re],
    [E.TABLE_CELL, se],
    [E.TABLE_HEADER, ie]
  ]), V = new Map([...D, ...Object.entries(i).map(([o, h]) => [o, h])]), ne = () => ({
    render: (d, f = {}, g) => {
      if (l && d) {
        const v = t.get(d) || 0;
        t.set(d, v + 1), f.key = `${d}-${v}`;
      }
      return r(d, f, g);
    },
    originalResolvers: D,
    mergedResolvers: V
  });
  function P(o) {
    const h = V.get(o.type);
    if (!h)
      return console.error("<Storyblok>", `No resolver found for node type ${o.type}`), "";
    const d = ne();
    if (o.type === "text") return h(o, d);
    const f = o.content ? o.content.map(U) : void 0;
    return h({
      ...o,
      children: f
    }, d);
  }
  function U(o) {
    return o.type === "doc" ? a ? o.content.map(P) : o.content.map(P).join("") : Array.isArray(o) ? o.map(P) : P(o);
  }
  return { render: U };
}
let J = !1;
const K = [], Z = (e) => new Promise((t, r) => {
  if (typeof window > "u") {
    r(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (i) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    J ? i() : K.push(i);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const s = document.createElement("script");
  s.async = !0, s.src = e, s.id = "storyblok-javascript-bridge", s.onerror = (i) => r(i), s.onload = (i) => {
    K.forEach((n) => n()), J = !0, t(i);
  }, document.getElementsByTagName("head")[0].appendChild(s);
}), j = (e = "") => e.includes("/cdn/"), me = (e, t = 25, r = 1) => ({
  ...e,
  per_page: t,
  page: r
}), pe = (e) => new Promise((t) => setTimeout(t, e)), Re = (e = 0, t) => Array.from({ length: e }, t), ve = (e = 0, t = e) => {
  const r = Math.abs(t - e) || 0, s = e < t ? 1 : -1;
  return Re(r, (i, n) => n * s + e);
}, _e = async (e, t) => Promise.all(e.map(t)), Ee = (e = [], t) => e.map(t).reduce((r, s) => [...r, ...s], []), B = (e, t, r) => {
  const s = [];
  for (const i in e) {
    if (!Object.prototype.hasOwnProperty.call(e, i)) continue;
    const n = e[i];
    if (n == null) continue;
    const l = r ? "" : encodeURIComponent(i);
    let a;
    typeof n == "object" ? a = B(n, t ? t + encodeURIComponent(`[${l}]`) : l, Array.isArray(n)) : a = `${t ? t + encodeURIComponent(`[${l}]`) : l}=${encodeURIComponent(n)}`, s.push(a);
  }
  return s.join("&");
}, W = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var Ae = class {
  constructor(e) {
    y(this, "baseURL");
    y(this, "timeout");
    y(this, "headers");
    y(this, "responseInterceptor");
    y(this, "fetch");
    y(this, "ejectInterceptor");
    y(this, "url");
    y(this, "parameters");
    y(this, "fetchOptions");
    this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((s) => {
      r.data = s;
    });
    for (const s of e.headers.entries()) t[s[0]] = s[1];
    return r.headers = { ...t }, r.status = e.status, r.statusText = e.statusText, r;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, r = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${B(this.parameters)}` : r = JSON.stringify(this.parameters);
    const s = new URL(t), i = new AbortController(), { signal: n } = i;
    let l = null;
    this.timeout && (l = setTimeout(() => i.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s}`, {
        method: e,
        headers: this.headers,
        body: r,
        signal: n,
        ...this.fetchOptions
      });
      this.timeout && l && clearTimeout(l);
      const u = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(u)) : this._statusHandler(u);
    } catch (a) {
      return a.name === "AbortError" ? { message: "Request timeout: The request was aborted due to timeout" } : { message: a.message || a.toString() || "An unknown error occurred" };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((r, s) => {
      if (t.test(`${e.status}`)) return r(e);
      const i = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      s(i);
    });
  }
}, Le = Ae;
const Q = "SB-Agent", G = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, we = {
  PUBLISHED: "published"
}, ke = 25, q = {
  SMALL: 25,
  MEDIUM: 50,
  LARGE: 75
}, C = {
  SINGLE_OR_SMALL: 50,
  MEDIUM: 15,
  LARGE: 10,
  VERY_LARGE: 6
}, X = 1e3, N = 3;
function Se(e, t) {
  const r = e.includes("/cdn/stories/"), s = e.split("/").length > 3 && !e.endsWith("/cdn/stories"), i = "find_by" in t;
  return r && s || i;
}
function Te(e) {
  return e <= q.SMALL ? C.SINGLE_OR_SMALL : e <= q.MEDIUM ? C.MEDIUM : e <= q.LARGE ? C.LARGE : C.VERY_LARGE;
}
function M(e, t, r = {}, s) {
  if (r.userRateLimit !== void 0) return Math.min(r.userRateLimit, X);
  if (r.serverHeadersRateLimit !== void 0) return Math.min(r.serverHeadersRateLimit, X);
  if (s !== void 0) return s;
  if (!e || !t || Se(e, t)) return C.SINGLE_OR_SMALL;
  const i = t.per_page || ke;
  return Te(i);
}
function Ce(e) {
  if (!e) return null;
  const t = e["x-ratelimit"] || e["X-RateLimit"], r = e["x-ratelimit-policy"] || e["X-RateLimit-Policy"];
  if (!t && !r) return null;
  const s = {};
  if (t) {
    const i = t.match(/r=(\d+)/);
    i && (s.remaining = Number.parseInt(i[1], 10));
  }
  if (r) {
    const i = r.match(/q=(\d+)/);
    i && (s.max = Number.parseInt(i[1], 10));
  }
  return Object.keys(s).length > 0 ? s : null;
}
function Ie(e, t = !1) {
  return {
    userRateLimit: e,
    serverHeadersRateLimit: void 0,
    isManagementApi: t
  };
}
var Oe = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function Pe(e, t, r) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(r)) throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let i = [], n = 0, l = !1;
  const a = async () => {
    n++;
    const c = s.shift();
    if (c) try {
      const m = await e(...c.args);
      c.resolve(m);
    } catch (m) {
      c.reject(m);
    }
    const b = setTimeout(() => {
      n--, s.length > 0 && a(), i = i.filter((m) => m !== b);
    }, r);
    i.includes(b) || i.push(b);
  }, u = (...c) => l ? Promise.reject(/* @__PURE__ */ new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((b, m) => {
    s.push({
      resolve: b,
      reject: m,
      args: c
    }), n < t && a();
  });
  return u.abort = () => {
    l = !0, i.forEach(clearTimeout), i = [], s.forEach((c) => c.reject(() => new Oe("Throttle function aborted"))), s.length = 0;
  }, u;
}
var xe = Pe, Ne = class {
  constructor(e, t = 1e3) {
    y(this, "queues");
    y(this, "interval");
    y(this, "throttledRequestFn");
    this.queues = /* @__PURE__ */ new Map(), this.interval = t, this.throttledRequestFn = e;
  }
  /**
  * Gets or creates a throttle queue for the specified rate limit
  */
  getQueue(e) {
    let t = this.queues.get(e);
    return t || (t = xe(this.throttledRequestFn, e, this.interval), this.queues.set(e, t)), t;
  }
  /**
  * Executes a request through the appropriate throttle queue based on rate limit
  */
  execute(e, ...t) {
    return this.getQueue(e)(...t);
  }
  /**
  * Aborts all throttle queues
  */
  abortAll() {
    this.queues.forEach((e) => {
      var t;
      (t = e.abort) == null || t.call(e);
    }), this.queues.clear();
  }
  /**
  * Gets the number of active queues
  */
  getQueueCount() {
    return this.queues.size;
  }
};
let $ = {};
const S = {};
var Me = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    y(this, "client");
    y(this, "maxRetries");
    y(this, "retriesDelay");
    y(this, "throttleManager");
    y(this, "accessToken");
    y(this, "cache");
    y(this, "resolveCounter");
    y(this, "relations");
    y(this, "links");
    y(this, "version");
    y(this, "rateLimitConfig");
    /**
    * @deprecated This property is deprecated. Use the standalone `richTextResolver` from `@storyblok/richtext` instead.
    * @see https://github.com/storyblok/richtext
    */
    y(this, "richTextResolver");
    y(this, "resolveNestedRelations");
    y(this, "stringifiedStoriesCache");
    y(this, "inlineAssets");
    let r = e.endpoint || t;
    if (!r) {
      const i = e.https === !1 ? "http" : "https";
      e.oauthToken ? r = `${i}://${W(e.region)}/v1` : r = `${i}://${W(e.region)}/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([n, l]) => {
      s.set(n, l);
    }), s.has(Q) || (s.set(Q, G.defaultAgentName), s.set(G.defaultAgentVersion, G.packageVersion)), e.oauthToken && s.set("Authorization", e.oauthToken), this.rateLimitConfig = Ie(e.rateLimit, !!e.oauthToken), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttleManager = new Ne(this.throttledRequest.bind(this), 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || we.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new Le({
      baseURL: r,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = S[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return j(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, r, s, i) {
    const n = this.factoryParamOptions(e, me(t, r, s));
    return this.cacheResponse(e, n, void 0, i);
  }
  get(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    j(s) && (t.version = t.version || this.version);
    const i = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, i, void 0, r);
  }
  async getAll(e, t = {}, r, s) {
    const i = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`.replace(/\/$/, ""), l = r ?? n.substring(n.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, u = await this.makeRequest(n, t, i, a, s), c = u.total ? Math.ceil(u.total / (u.perPage || i)) : 1, b = await _e(ve(a, c), (m) => this.makeRequest(n, t, i, m + 1, s));
    return Ee([u, ...b], (m) => Object.values(m.data[l]));
  }
  post(e, t = {}, r) {
    const s = `/${e}`, i = M(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i, "post", s, t, r);
  }
  put(e, t = {}, r) {
    const s = `/${e}`, i = M(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i, "put", s, t, r);
  }
  delete(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`, i = M(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i, "delete", s, t, r);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, r) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, r);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, r) {
    const s = e[t];
    s && s.fieldtype === "multilink" && s.linktype === "story" && typeof s.id == "string" && this.links[r][s.id] ? s.story = this._cleanCopy(this.links[r][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[r][s.uuid] && (s.story = this._cleanCopy(this.links[r][s.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, r) {
    const s = e[t];
    typeof s == "string" ? e[t] = this.getStoryReference(r, s) : Array.isArray(s) && (e[t] = s.map((i) => this.getStoryReference(r, i)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, r, s) {
    if (Array.isArray(r) ? r.find((l) => l.endsWith(`.${t}`)) : r.endsWith(`.${t}`)) {
      this._resolveField(e, t, s);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(r) ? r.includes(n) : r === n) && this._resolveField(e, t, s);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, r) {
    const s = (i, n = "") => {
      if (!(!i || i._stopResolving)) {
        if (Array.isArray(i)) i.forEach((l, a) => s(l, `${n}[${a}]`));
        else if (typeof i == "object") for (const l in i) {
          const a = n ? `${n}.${l}` : l;
          (i.component && i._uid || i.type === "link") && (this._insertRelations(i, l, t, r), this._insertLinks(i, l, r)), s(i[l], a);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t, r) {
    let s = [];
    if (e.link_uuids) {
      const i = e.link_uuids.length, n = [], l = 50;
      for (let a = 0; a < i; a += l) {
        const u = Math.min(i, a + l);
        n.push(e.link_uuids.slice(a, u));
      }
      for (let a = 0; a < n.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[a].join(",")
        })).data.stories.forEach((c) => {
          s.push(c);
        });
    } else s = e.links;
    s.forEach((i) => {
      this.links[r][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, r) {
    let s = [];
    if (e.rel_uuids) {
      const i = e.rel_uuids.length, n = [], l = 50;
      for (let a = 0; a < i; a += l) {
        const u = Math.min(i, a + l);
        n.push(e.rel_uuids.slice(a, u));
      }
      for (let a = 0; a < n.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c) => {
          s.push(c);
        });
      s.length > 0 && (e.rels = s, delete e.rel_uuids);
    } else s = e.rels;
    s && s.length > 0 && s.forEach((i) => {
      this.relations[r][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, r) {
    var i, n;
    let s = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (s = t.resolve_relations.split(",")), await this.resolveRelations(e, t, r)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((i = e.links) != null && i.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, r), this.resolveNestedRelations) for (const l in this.relations[r]) this.iterateTree(this.relations[r][l], s, r);
    e.story ? this.iterateTree(e.story, s, r) : e.stories.forEach((l) => {
      this.iterateTree(l, s, r);
    }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(e, t, r, s) {
    const i = B({
      url: e,
      params: t
    }), n = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const c = await n.get(i);
      if (c) return Promise.resolve(c);
    }
    const a = !j(e) && this.rateLimitConfig.isManagementApi ? N : void 0, u = M(e, t, this.rateLimitConfig, a);
    return new Promise(async (c, b) => {
      var m;
      try {
        const R = await this.throttleManager.execute(u, "get", e, t, s);
        if (R.status !== 200) return b(R);
        let A = {
          data: R.data,
          headers: R.headers
        };
        const _ = Ce(R.headers);
        if ((_ == null ? void 0 : _.max) !== void 0 && (this.rateLimitConfig.serverHeadersRateLimit = _.max), (m = R.headers) != null && m["per-page"] && (A = Object.assign({}, A, {
          perPage: R.headers["per-page"] ? Number.parseInt(R.headers["per-page"]) : 0,
          total: R.headers["per-page"] ? Number.parseInt(R.headers.total) : 0
        })), A.data.story || A.data.stories) {
          const H = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(A.data, t, `${H}`), A = await this.processInlineAssets(A);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await n.set(i, A);
        const T = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && A.data.cv && (T && S[t.token] && S[t.token] !== A.data.cv && await this.flushCache(), S[t.token] = A.data.cv), c(A);
      } catch (R) {
        if (R.response && R.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await pe(this.retriesDelay), this.cacheResponse(e, t, r).then(c).catch(b);
        b(R);
      }
    });
  }
  throttledRequest(e, t, r, s) {
    return this.client.setFetchOptions(s), this.client[e](t, r);
  }
  cacheVersions() {
    return S;
  }
  cacheVersion() {
    return S[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (S[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (S[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve($[e]);
          },
          getAll() {
            return Promise.resolve($);
          },
          set(e, t) {
            return $[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return $ = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (r) => {
      if (!r || typeof r != "object") return r;
      if (Array.isArray(r)) return r.map((i) => t(i));
      let s = { ...r };
      s.fieldtype === "asset" && Array.isArray(e.data.assets) && (s = {
        ...e.data.assets.find((i) => i.id === s.id),
        ...s
      });
      for (const i in s) typeof s[i] == "object" && (s[i] = t(s[i]));
      return s;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((r) => (r.content = t(r.content), r))), e;
  }
}, $e = Me;
const Ue = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new $e(t) };
}, je = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
let F = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const Ge = (e, t, r = {}) => {
  var a;
  const i = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n = new URL((a = window.location) == null ? void 0 : a.href).searchParams.get(
    "_storyblok"
  ), l = n !== null && +n === e;
  if (!(!i || !l)) {
    if (!e) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(r).on(["input", "published", "change"], (c) => {
        var b;
        c && (c.action === "input" && ((b = c.story) == null ? void 0 : b.id) === e ? t(c.story) : (c.action === "change" || c.action === "published") && c.storyId === e && window.location.reload());
      });
    });
  }
}, qe = (e = {}) => {
  var b, m;
  const {
    bridge: t,
    accessToken: r,
    use: s = [],
    apiOptions: i = {},
    bridgeUrl: n
  } = e;
  i.accessToken = i.accessToken || r;
  const l = { bridge: t, apiOptions: i };
  let a = {};
  s.forEach((R) => {
    a = { ...a, ...R(l) };
  }), n && (F = n);
  const c = !(typeof window > "u") && ((m = (b = window.location) == null ? void 0 : b.search) == null ? void 0 : m.includes("_storyblok_tk"));
  return t !== !1 && c && Z(F), a;
};
function Fe(e, t) {
  return be(t).render(e);
}
const Be = () => Z(F);
export {
  E as BlockTypes,
  w as MarkTypes,
  $e as StoryblokClient,
  ue as TextTypes,
  Ue as apiPlugin,
  Be as loadStoryblokBridge,
  Ge as registerStoryblokBridge,
  Fe as renderRichText,
  be as richTextResolver,
  je as storyblokEditable,
  qe as storyblokInit,
  Ge as useStoryblokBridge
};
