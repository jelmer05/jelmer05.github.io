/**
 * name: @storyblok/vue
 * (c) 2025
 * description: SDK to integrate Storyblok into your project using Vue.
 * author: Storyblok
 */
import { defineComponent as W, ref as x, resolveDynamicComponent as H, inject as de, createBlock as X, openBlock as Q, mergeProps as pe, createSlots as fe, renderList as ye, withCtx as me, renderSlot as ge, normalizeProps as be, guardReactiveProps as ve, h as Z, createTextVNode as ke, watch as we, onMounted as Te, defineAsyncComponent as _e } from "vue";
var Re = Object.defineProperty, $e = (e, t, r) => t in e ? Re(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, b = (e, t, r) => $e(e, typeof t != "symbol" ? t + "" : t, r);
let k = /* @__PURE__ */ function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
}({}), _ = /* @__PURE__ */ function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
}({}), Ae = /* @__PURE__ */ function(e) {
  return e.TEXT = "text", e;
}({}), O = /* @__PURE__ */ function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
}({});
const Ee = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], Se = (e = {}) => {
  const { custom: t, ...r } = e, s = {
    ...r,
    ...t
  };
  return Object.keys(s).map((n) => `${n}="${s[n]}"`).join(" ");
}, Le = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function Ie(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const L = (e) => Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== void 0));
function Ce(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let r = 0, s = 0;
  const n = {}, o = [];
  function l(c, u, f, y, R) {
    typeof c != "number" || c <= u || c >= f ? console.warn(`[StoryblokRichText] - ${y.charAt(0).toUpperCase() + y.slice(1)} value must be a number between ${u} and ${f} (inclusive)`) : R.push(`${y}(${c})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (n.width = t.width, r = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (n.height = t.height, s = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete n.width, delete n.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (n.loading = t.loading), t.class && (n.class = t.class), t.filters) {
      const { filters: c } = t || {}, { blur: u, brightness: f, fill: y, format: R, grayscale: P, quality: T, rotate: E } = c || {};
      u && l(u, 0, 100, "blur", o), T && l(T, 0, 100, "quality", o), f && l(f, 0, 100, "brightness", o), y && o.push(`fill(${y})`), P && o.push("grayscale()"), E && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && o.push(`rotate(${E})`), R && [
        "webp",
        "png",
        "jpeg"
      ].includes(R) && o.push(`format(${R})`);
    }
    t.srcset && (n.srcset = t.srcset.map((c) => {
      if (typeof c == "number") return `${e}/m/${c}x0/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${c}w`;
      if (Array.isArray(c) && c.length === 2) {
        const [u, f] = c;
        return `${e}/m/${u}x${f}/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${u}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (n.sizes = t.sizes.join(", "));
  }
  let a = `${e}/m/`;
  return (r > 0 || s > 0) && (a = `${a}${r}x${s}/`), o.length > 0 && (a = `${a}filters:${o.join(":")}`), {
    src: a,
    attrs: n
  };
}
function V(e, t = {}, r) {
  const s = Se(t), n = s ? `${e} ${s}` : e, o = Array.isArray(r) ? r.join("") : r || "";
  if (e) {
    if (Ee.includes(e)) return `<${n}>`;
  } else return o;
  return `<${n}>${o}</${e}>`;
}
function ee(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: r = V, textFn: s = Ie, resolvers: n = {}, optimizeImages: o = !1, keyedResolvers: l = !1 } = e, a = r !== V, c = (i = {}) => {
    const { textAlign: h, class: d, id: p, style: m, ...v } = i, g = [];
    return m && g.push(m.endsWith(";") ? m : `${m};`), h && g.push(`text-align: ${h};`), L({
      ...v,
      class: d,
      id: p,
      ...g.length > 0 ? { style: g.join(" ") } : {}
    });
  }, u = (i) => (h, d) => {
    const p = c(h.attrs);
    return d.render(i, p, h.children || null);
  }, f = (i, h) => {
    const { src: d, alt: p, title: m, srcset: v, sizes: g } = i.attrs || {};
    let $ = d, w = {};
    if (o) {
      const { src: ue, attrs: he } = Ce(d, o);
      $ = ue, w = he;
    }
    const S = {
      src: $,
      alt: p,
      title: m,
      srcset: v,
      sizes: g,
      ...w
    };
    return h.render("img", L(S));
  }, y = (i, h) => {
    const { level: d, ...p } = i.attrs || {}, m = c(p);
    return h.render(`h${d}`, m, i.children);
  }, R = (i, h) => {
    var d, p, m, v;
    const g = h.render("img", {
      src: (d = i.attrs) == null ? void 0 : d.fallbackImage,
      alt: (p = i.attrs) == null ? void 0 : p.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h.render("span", {
      "data-type": "emoji",
      "data-name": (m = i.attrs) == null ? void 0 : m.name,
      "data-emoji": (v = i.attrs) == null ? void 0 : v.emoji
    }, g);
  }, P = (i, h) => h.render("pre", i.attrs || {}, h.render("code", {}, i.children || "")), T = (i, h = !1) => ({ text: d, attrs: p }, m) => {
    const { class: v, id: g, ...$ } = p || {}, w = h ? {
      class: v,
      id: g,
      style: Le($) || void 0
    } : p || {};
    return m.render(i, L(w), d);
  }, E = (i) => N(i), se = (i) => {
    const { marks: h, ...d } = i;
    if ("text" in i) {
      if (h) return h.reduce((m, v) => E({
        ...v,
        text: m
      }), E({
        ...d,
        children: d.children
      }));
      const p = i.attrs || {};
      if (l) {
        const m = t.get("txt") || 0;
        t.set("txt", m + 1), p.key = `txt-${m}`;
      }
      return s(d.text, p);
    }
    return "";
  }, B = (i, h) => {
    const { linktype: d, href: p, anchor: m, ...v } = i.attrs || {};
    let g = "";
    switch (d) {
      case O.ASSET:
      case O.URL:
        g = p;
        break;
      case O.EMAIL:
        g = `mailto:${p}`;
        break;
      case O.STORY:
        g = p, m && (g = `${g}#${m}`);
        break;
      default:
        g = p;
        break;
    }
    const $ = { ...v };
    return g && ($.href = g), h.render("a", $, i.text);
  }, ne = (i, h) => {
    var d, p;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h.render("span", {
      blok: (d = i == null ? void 0 : i.attrs) == null ? void 0 : d.body[0],
      id: (p = i.attrs) == null ? void 0 : p.id,
      style: "display: none"
    });
  }, oe = (i, h) => {
    const d = c(i.attrs), p = i.children || null;
    return h.render("table", d, h.render("tbody", {}, p));
  }, ie = (i, h) => {
    const d = c(i.attrs);
    return h.render("tr", d, i.children);
  }, ae = (i, h) => {
    const { colspan: d, rowspan: p, colwidth: m, backgroundColor: v, textAlign: g, ...$ } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), v && w.push(`background-color: ${v};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...$,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h.render("td", L(S), i.children);
  }, le = (i, h) => {
    const { colspan: d, rowspan: p, colwidth: m, backgroundColor: v, textAlign: g, ...$ } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), v && w.push(`background-color: ${v};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...$,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h.render("th", L(S), i.children);
  }, M = /* @__PURE__ */ new Map([
    [k.DOCUMENT, u("")],
    [k.HEADING, y],
    [k.PARAGRAPH, u("p")],
    [k.UL_LIST, u("ul")],
    [k.OL_LIST, u("ol")],
    [k.LIST_ITEM, u("li")],
    [k.IMAGE, f],
    [k.EMOJI, R],
    [k.CODE_BLOCK, P],
    [k.HR, u("hr")],
    [k.BR, u("br")],
    [k.QUOTE, u("blockquote")],
    [k.COMPONENT, ne],
    [Ae.TEXT, se],
    [_.LINK, B],
    [_.ANCHOR, B],
    [_.STYLED, T("span", !0)],
    [_.BOLD, T("strong")],
    [_.TEXT_STYLE, T("span", !0)],
    [_.ITALIC, T("em")],
    [_.UNDERLINE, T("u")],
    [_.STRIKE, T("s")],
    [_.CODE, T("code")],
    [_.SUPERSCRIPT, T("sup")],
    [_.SUBSCRIPT, T("sub")],
    [_.HIGHLIGHT, T("mark")],
    [k.TABLE, oe],
    [k.TABLE_ROW, ie],
    [k.TABLE_CELL, ae],
    [k.TABLE_HEADER, le]
  ]), F = new Map([...M, ...Object.entries(n).map(([i, h]) => [i, h])]), ce = () => ({
    render: (i, h = {}, d) => {
      if (l && i) {
        const p = t.get(i) || 0;
        t.set(i, p + 1), h.key = `${i}-${p}`;
      }
      return r(i, h, d);
    },
    originalResolvers: M,
    mergedResolvers: F
  });
  function C(i) {
    const h = F.get(i.type);
    if (!h)
      return console.error("<Storyblok>", `No resolver found for node type ${i.type}`), "";
    const d = ce();
    if (i.type === "text") return h(i, d);
    const p = i.content ? i.content.map(N) : void 0;
    return h({
      ...i,
      children: p
    }, d);
  }
  function N(i) {
    return i.type === "doc" ? a ? i.content.map(C) : i.content.map(C).join("") : Array.isArray(i) ? i.map(C) : C(i);
  }
  return { render: N };
}
let z = !1;
const q = [], Oe = (e) => new Promise((t, r) => {
  if (typeof window > "u") {
    r(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (n) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    z ? n() : q.push(n);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const s = document.createElement("script");
  s.async = !0, s.src = e, s.id = "storyblok-javascript-bridge", s.onerror = (n) => r(n), s.onload = (n) => {
    q.forEach((o) => o()), z = !0, t(n);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var je = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function xe(e, t, r) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(r)) throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let n = [], o = 0, l = !1;
  const a = async () => {
    o++;
    const u = s.shift();
    if (u) try {
      const y = await e(...u.args);
      u.resolve(y);
    } catch (y) {
      u.reject(y);
    }
    const f = setTimeout(() => {
      o--, s.length > 0 && a(), n = n.filter((y) => y !== f);
    }, r);
    n.includes(f) || n.push(f);
  }, c = (...u) => l ? Promise.reject(/* @__PURE__ */ new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((f, y) => {
    s.push({
      resolve: f,
      reject: y,
      args: u
    }), o < t && a();
  });
  return c.abort = () => {
    l = !0, n.forEach(clearTimeout), n = [], s.forEach((u) => u.reject(() => new je("Throttle function aborted"))), s.length = 0;
  }, c;
}
var Pe = xe;
const G = (e = "") => e.includes("/cdn/"), Ne = (e, t = 25, r = 1) => ({
  ...e,
  per_page: t,
  page: r
}), He = (e) => new Promise((t) => setTimeout(t, e)), Ue = (e = 0, t) => Array.from({ length: e }, t), De = (e = 0, t = e) => {
  const r = Math.abs(t - e) || 0, s = e < t ? 1 : -1;
  return Ue(r, (n, o) => o * s + e);
}, Be = async (e, t) => Promise.all(e.map(t)), Me = (e = [], t) => e.map(t).reduce((r, s) => [...r, ...s], []), D = (e, t, r) => {
  const s = [];
  for (const n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n)) continue;
    const o = e[n];
    if (o == null) continue;
    const l = r ? "" : encodeURIComponent(n);
    let a;
    typeof o == "object" ? a = D(o, t ? t + encodeURIComponent(`[${l}]`) : l, Array.isArray(o)) : a = `${t ? t + encodeURIComponent(`[${l}]`) : l}=${encodeURIComponent(o)}`, s.push(a);
  }
  return s.join("&");
}, J = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var Fe = class {
  constructor(e) {
    b(this, "baseURL"), b(this, "timeout"), b(this, "headers"), b(this, "responseInterceptor"), b(this, "fetch"), b(this, "ejectInterceptor"), b(this, "url"), b(this, "parameters"), b(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((s) => {
      r.data = s;
    });
    for (const s of e.headers.entries()) t[s[0]] = s[1];
    return r.headers = { ...t }, r.status = e.status, r.statusText = e.statusText, r;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, r = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${D(this.parameters)}` : r = JSON.stringify(this.parameters);
    const s = new URL(t), n = new AbortController(), { signal: o } = n;
    let l;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s}`, {
        method: e,
        headers: this.headers,
        body: r,
        signal: o,
        ...this.fetchOptions
      });
      this.timeout && clearTimeout(l);
      const c = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (a) {
      return { message: a };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((r, s) => {
      if (t.test(`${e.status}`)) return r(e);
      const n = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      s(n);
    });
  }
}, Ve = Fe;
const K = "SB-Agent", U = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, ze = {
  PUBLISHED: "published"
};
let j = {};
const A = {};
var qe = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    b(this, "client"), b(this, "maxRetries"), b(this, "retriesDelay"), b(this, "throttle"), b(this, "accessToken"), b(this, "cache"), b(this, "resolveCounter"), b(this, "relations"), b(this, "links"), b(this, "version"), b(this, "richTextResolver"), b(this, "resolveNestedRelations"), b(this, "stringifiedStoriesCache"), b(this, "inlineAssets");
    let r = e.endpoint || t;
    if (!r) {
      const o = e.https === !1 ? "http" : "https";
      e.oauthToken ? r = `${o}://${J(e.region)}/v1` : r = `${o}://${J(e.region)}/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([o, l]) => {
      s.set(o, l);
    }), s.has(K) || (s.set(K, U.defaultAgentName), s.set(U.defaultAgentVersion, U.packageVersion));
    let n = 5;
    e.oauthToken && (s.set("Authorization", e.oauthToken), n = 3), e.rateLimit && (n = e.rateLimit), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = Pe(this.throttledRequest.bind(this), n, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || ze.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new Ve({
      baseURL: r,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = A[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return G(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, r, s, n) {
    const o = this.factoryParamOptions(e, Ne(t, r, s));
    return this.cacheResponse(e, o, void 0, n);
  }
  get(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    G(s) && (t.version = t.version || this.version);
    const n = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, n, void 0, r);
  }
  async getAll(e, t = {}, r, s) {
    const n = (t == null ? void 0 : t.per_page) || 25, o = `/${e}`.replace(/\/$/, ""), l = r ?? o.substring(o.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, c = await this.makeRequest(o, t, n, a, s), u = c.total ? Math.ceil(c.total / (c.perPage || n)) : 1, f = await Be(De(a, u), (y) => this.makeRequest(o, t, n, y + 1, s));
    return Me([c, ...f], (y) => Object.values(y.data[l]));
  }
  post(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("post", s, t, r);
  }
  put(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("put", s, t, r);
  }
  delete(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    return this.throttle("delete", s, t, r);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, r) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, r);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, r) {
    const s = e[t];
    s && s.fieldtype === "multilink" && s.linktype === "story" && typeof s.id == "string" && this.links[r][s.id] ? s.story = this._cleanCopy(this.links[r][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[r][s.uuid] && (s.story = this._cleanCopy(this.links[r][s.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, r) {
    const s = e[t];
    typeof s == "string" ? e[t] = this.getStoryReference(r, s) : Array.isArray(s) && (e[t] = s.map((n) => this.getStoryReference(r, n)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, r, s) {
    if (Array.isArray(r) ? r.find((o) => o.endsWith(`.${t}`)) : r.endsWith(`.${t}`)) {
      this._resolveField(e, t, s);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(r) ? r.includes(n) : r === n) && this._resolveField(e, t, s);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, r) {
    const s = (n, o = "") => {
      if (!(!n || n._stopResolving)) {
        if (Array.isArray(n)) n.forEach((l, a) => s(l, `${o}[${a}]`));
        else if (typeof n == "object") for (const l in n) {
          const a = o ? `${o}.${l}` : l;
          (n.component && n._uid || n.type === "link") && (this._insertRelations(n, l, t, r), this._insertLinks(n, l, r)), s(n[l], a);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t, r) {
    let s = [];
    if (e.link_uuids) {
      const n = e.link_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.link_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(",")
        })).data.stories.forEach((c) => {
          s.push(c);
        });
    } else s = e.links;
    s.forEach((n) => {
      this.links[r][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, r) {
    let s = [];
    if (e.rel_uuids) {
      const n = e.rel_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.rel_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c) => {
          s.push(c);
        });
      s.length > 0 && (e.rels = s, delete e.rel_uuids);
    } else s = e.rels;
    s && s.length > 0 && s.forEach((n) => {
      this.relations[r][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, r) {
    var s, n;
    let o = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (o = t.resolve_relations.split(",")), await this.resolveRelations(e, t, r)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((s = e.links) != null && s.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, r), this.resolveNestedRelations) for (const l in this.relations[r]) this.iterateTree(this.relations[r][l], o, r);
    e.story ? this.iterateTree(e.story, o, r) : e.stories.forEach((l) => {
      this.iterateTree(l, o, r);
    }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(e, t, r, s) {
    const n = D({
      url: e,
      params: t
    }), o = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const l = await o.get(n);
      if (l) return Promise.resolve(l);
    }
    return new Promise(async (l, a) => {
      var c;
      try {
        const u = await this.throttle("get", e, t, s);
        if (u.status !== 200) return a(u);
        let f = {
          data: u.data,
          headers: u.headers
        };
        if ((c = u.headers) != null && c["per-page"] && (f = Object.assign({}, f, {
          perPage: u.headers["per-page"] ? Number.parseInt(u.headers["per-page"]) : 0,
          total: u.headers["per-page"] ? Number.parseInt(u.headers.total) : 0
        })), f.data.story || f.data.stories) {
          const R = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(f.data, t, `${R}`), f = await this.processInlineAssets(f);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await o.set(n, f);
        const y = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && f.data.cv && (y && A[t.token] && A[t.token] !== f.data.cv && await this.flushCache(), A[t.token] = f.data.cv), l(f);
      } catch (u) {
        if (u.response && u.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await He(this.retriesDelay), this.cacheResponse(e, t, r).then(l).catch(a);
        a(u);
      }
    });
  }
  throttledRequest(e, t, r, s) {
    return this.client.setFetchOptions(s), this.client[e](t, r);
  }
  cacheVersions() {
    return A;
  }
  cacheVersion() {
    return A[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (A[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (A[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(j[e]);
          },
          getAll() {
            return Promise.resolve(j);
          },
          set(e, t) {
            return j[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return j = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (r) => {
      if (!r || typeof r != "object") return r;
      if (Array.isArray(r)) return r.map((n) => t(n));
      let s = { ...r };
      s.fieldtype === "asset" && Array.isArray(e.data.assets) && (s = {
        ...e.data.assets.find((n) => n.id === s.id),
        ...s
      });
      for (const n in s) typeof s[n] == "object" && (s[n] = t(s[n]));
      return s;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((r) => (r.content = t(r.content), r))), e;
  }
}, Ge = qe;
const tt = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new Ge(t) };
}, Je = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
let Y = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const Ke = (e, t, r = {}) => {
  var s;
  const n = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", o = new URL((s = window.location) == null ? void 0 : s.href).searchParams.get(
    "_storyblok"
  ), l = o !== null && +o === e;
  if (!(!n || !l)) {
    if (!e) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(r).on(["input", "published", "change"], (a) => {
        var c;
        a && (a.action === "input" && ((c = a.story) == null ? void 0 : c.id) === e ? t(a.story) : (a.action === "change" || a.action === "published") && a.storyId === e && window.location.reload());
      });
    });
  }
}, Ye = (e = {}) => {
  var t, r;
  const {
    bridge: s,
    accessToken: n,
    use: o = [],
    apiOptions: l = {},
    bridgeUrl: a
  } = e;
  l.accessToken = l.accessToken || n;
  const c = { bridge: s, apiOptions: l };
  let u = {};
  o.forEach((y) => {
    u = { ...u, ...y(c) };
  }), a && (Y = a);
  const f = !(typeof window > "u") && ((r = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : r.includes("_storyblok_tk"));
  return s !== !1 && f && Oe(Y), u;
};
function rt(e, t) {
  return ee(t).render(e);
}
const te = /* @__PURE__ */ W({
  __name: "StoryblokComponent",
  props: {
    blok: {}
  },
  setup(e, { expose: t }) {
    var a;
    const r = e, s = x();
    t({
      value: s
    });
    const n = typeof H(r.blok.component) != "string", o = de("VueSDKOptions"), l = x((a = r.blok.component) == null ? void 0 : a.replace(/_/g, "-"));
    return !n && o && (o.enableFallbackComponent ? (l.value = o.customFallbackComponent ?? "FallbackComponent", typeof H(l.value) == "string" && console.error(
      `Is the Fallback component "${l.value}" registered properly?`
    )) : console.error(
      `Component could not be found for blok "${r.blok.component}"! Is it defined in main.ts as "app.component("${r.blok.component}", ${r.blok.component});"?`
    )), (c, u) => (Q(), X(H(l.value), pe({
      ref_key: "blokRef",
      ref: s
    }, { ...c.$props, ...c.$attrs }), fe({ _: 2 }, [
      ye(c.$slots, (f, y) => ({
        name: y,
        fn: me((R) => [
          ge(c.$slots, y, be(ve(R)))
        ])
      }))
    ]), 1040));
  }
}), We = (e) => {
  var r;
  const t = (r = e == null ? void 0 : e.attrs) == null ? void 0 : r.body;
  return !Array.isArray(t) || t.length === 0 ? [] : t.map(
    (s) => {
      var n;
      return Z(te, {
        blok: s,
        id: (n = e == null ? void 0 : e.attrs) == null ? void 0 : n.id
      }, e.children);
    }
  );
};
function Xe(e) {
  const t = {
    renderFn: Z,
    // TODO: Check why this changed.
    // @ts-expect-error - createTextVNode types has been recently changed.
    textFn: ke,
    keyedResolvers: !0,
    resolvers: {
      [k.COMPONENT]: We,
      ...e.resolvers
    }
  };
  return ee(t);
}
const Qe = /* @__PURE__ */ W({
  __name: "StoryblokRichText",
  props: {
    doc: {},
    resolvers: {}
  },
  setup(e) {
    const t = e, r = x(), s = () => r.value;
    return we([() => t.doc, () => t.resolvers], ([n, o]) => {
      const { render: l } = Xe({
        resolvers: o ?? {}
      });
      r.value = l(n);
    }, {
      immediate: !0,
      deep: !0
    }), (n, o) => (Q(), X(s));
  }
}), Ze = {
  beforeMount(e, t) {
    if (t.value) {
      const r = Je(t.value);
      Object.keys(r).length > 0 && (e.setAttribute("data-blok-c", r["data-blok-c"]), e.setAttribute("data-blok-uid", r["data-blok-uid"]), e.classList.add("storyblok__outline"));
    }
  }
}, re = (e) => {
  console.error(`You can't use ${e} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
let I = null;
const st = () => (I || re("useStoryblokApi"), I), nt = async (e, t = {}, r = {}) => {
  const s = x(null);
  if (r.resolveRelations = r.resolveRelations ?? t.resolve_relations, r.resolveLinks = r.resolveLinks ?? t.resolve_links, Te(() => {
    s.value && s.value.id && Ke(
      s.value.id,
      (n) => s.value = n,
      r
    );
  }), I) {
    const { data: n } = await I.get(
      `cdn/stories/${e}`,
      t
    );
    s.value = n.story;
  } else
    re("useStoryblok");
  return s;
}, ot = {
  install(e, t = {}) {
    e.directive("editable", Ze), e.component("StoryblokComponent", te), e.component("StoryblokRichText", Qe), t.enableFallbackComponent && !t.customFallbackComponent && e.component(
      "FallbackComponent",
      _e(() => import("./FallbackComponent-vpkAikkq.js"))
    );
    const { storyblokApi: r } = Ye(t);
    I = r || null, e.provide("VueSDKOptions", t);
  }
};
export {
  k as BlockTypes,
  _ as MarkTypes,
  te as StoryblokComponent,
  Qe as StoryblokRichText,
  ot as StoryblokVue,
  Ae as TextTypes,
  tt as apiPlugin,
  rt as renderRichText,
  ee as richTextResolver,
  nt as useStoryblok,
  st as useStoryblokApi,
  Ke as useStoryblokBridge,
  Xe as useStoryblokRichText
};
