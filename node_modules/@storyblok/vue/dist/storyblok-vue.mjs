/**
 * name: @storyblok/vue
 * (c) 2026
 * description: SDK to integrate Storyblok into your project using Vue.
 * author: Storyblok
 */
import { defineComponent as te, ref as H, resolveDynamicComponent as D, inject as ge, createBlock as se, openBlock as re, mergeProps as ve, createSlots as be, renderList as ke, withCtx as Re, renderSlot as we, normalizeProps as _e, guardReactiveProps as Te, h as ne, createTextVNode as Ae, watch as Le, onMounted as Ee, defineAsyncComponent as $e } from "vue";
var Se = Object.defineProperty, Ie = (e, t, s) => t in e ? Se(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, y = (e, t, s) => Ie(e, typeof t != "symbol" ? t + "" : t, s);
let R = /* @__PURE__ */ function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
}({}), T = /* @__PURE__ */ function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
}({}), Ce = /* @__PURE__ */ function(e) {
  return e.TEXT = "text", e;
}({}), j = /* @__PURE__ */ function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
}({});
const xe = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], Oe = (e = {}) => {
  const { custom: t, ...s } = e, r = {
    ...s,
    ...t
  };
  return Object.keys(r).map((n) => `${n}="${r[n]}"`).join(" ");
}, je = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function Pe(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const I = (e) => Object.fromEntries(Object.entries(e).filter(([t, s]) => s !== void 0));
function Me(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let s = 0, r = 0;
  const n = {}, o = [];
  function l(c, d, v, h, b) {
    typeof c != "number" || c <= d || c >= v ? console.warn(`[StoryblokRichText] - ${h.charAt(0).toUpperCase() + h.slice(1)} value must be a number between ${d} and ${v} (inclusive)`) : b.push(`${h}(${c})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (n.width = t.width, s = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (n.height = t.height, r = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete n.width, delete n.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (n.loading = t.loading), t.class && (n.class = t.class), t.filters) {
      const { filters: c } = t || {}, { blur: d, brightness: v, fill: h, format: b, grayscale: E, quality: _, rotate: $ } = c || {};
      d && l(d, 0, 100, "blur", o), _ && l(_, 0, 100, "quality", o), v && l(v, 0, 100, "brightness", o), h && o.push(`fill(${h})`), E && o.push("grayscale()"), $ && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && o.push(`rotate(${$})`), b && [
        "webp",
        "png",
        "jpeg"
      ].includes(b) && o.push(`format(${b})`);
    }
    t.srcset && (n.srcset = t.srcset.map((c) => {
      if (typeof c == "number") return `${e}/m/${c}x0/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${c}w`;
      if (Array.isArray(c) && c.length === 2) {
        const [d, v] = c;
        return `${e}/m/${d}x${v}/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${d}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (n.sizes = t.sizes.join(", "));
  }
  let a = `${e}/m/`;
  return (s > 0 || r > 0) && (a = `${a}${s}x${r}/`), o.length > 0 && (a = `${a}filters:${o.join(":")}`), {
    src: a,
    attrs: n
  };
}
function J(e, t = {}, s) {
  const r = Oe(t), n = r ? `${e} ${r}` : e, o = Array.isArray(s) ? s.join("") : s || "";
  if (e) {
    if (xe.includes(e)) return `<${n}>`;
  } else return o;
  return `<${n}>${o}</${e}>`;
}
function oe(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: s = J, textFn: r = Pe, resolvers: n = {}, optimizeImages: o = !1, keyedResolvers: l = !1 } = e, a = s !== J, c = (i = {}) => {
    const { textAlign: u, class: p, id: f, style: m, ...k } = i, g = [];
    return m && g.push(m.endsWith(";") ? m : `${m};`), u && g.push(`text-align: ${u};`), I({
      ...k,
      class: p,
      id: f,
      ...g.length > 0 ? { style: g.join(" ") } : {}
    });
  }, d = (i) => (u, p) => {
    const f = c(u.attrs);
    return p.render(i, f, u.children || null);
  }, v = (i, u) => {
    const { src: p, alt: f, title: m, srcset: k, sizes: g } = i.attrs || {};
    let A = p, w = {};
    if (o) {
      const { src: me, attrs: ye } = Me(p, o);
      A = me, w = ye;
    }
    const S = {
      src: A,
      alt: f,
      title: m,
      srcset: k,
      sizes: g,
      ...w
    };
    return u.render("img", I(S));
  }, h = (i, u) => {
    const { level: p, ...f } = i.attrs || {}, m = c(f);
    return u.render(`h${p}`, m, i.children);
  }, b = (i, u) => {
    var p, f, m, k;
    const g = u.render("img", {
      src: (p = i.attrs) == null ? void 0 : p.fallbackImage,
      alt: (f = i.attrs) == null ? void 0 : f.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return u.render("span", {
      "data-type": "emoji",
      "data-name": (m = i.attrs) == null ? void 0 : m.name,
      "data-emoji": (k = i.attrs) == null ? void 0 : k.emoji
    }, g);
  }, E = (i, u) => u.render("pre", i.attrs || {}, u.render("code", {}, i.children || "")), _ = (i, u = !1) => ({ text: p, attrs: f }, m) => {
    const { class: k, id: g, ...A } = f || {}, w = u ? {
      class: k,
      id: g,
      style: je(A) || void 0
    } : f || {};
    return m.render(i, I(w), p);
  }, $ = (i) => U(i), le = (i) => {
    const { marks: u, ...p } = i;
    if ("text" in i) {
      if (u) return u.reduce((m, k) => $({
        ...k,
        text: m
      }), $({
        ...p,
        children: p.children
      }));
      const f = i.attrs || {};
      if (l) {
        const m = t.get("txt") || 0;
        t.set("txt", m + 1), f.key = `txt-${m}`;
      }
      return r(p.text, f);
    }
    return "";
  }, V = (i, u) => {
    const { linktype: p, href: f, anchor: m, ...k } = i.attrs || {};
    let g = "";
    switch (p) {
      case j.ASSET:
      case j.URL:
        g = f;
        break;
      case j.EMAIL:
        g = `mailto:${f}`;
        break;
      case j.STORY:
        g = f, m && (g = `${g}#${m}`);
        break;
      default:
        g = f;
        break;
    }
    const A = { ...k };
    return g && (A.href = g), u.render("a", A, i.text);
  }, ce = (i, u) => {
    var p, f;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), u.render("span", {
      blok: (p = i == null ? void 0 : i.attrs) == null ? void 0 : p.body[0],
      id: (f = i.attrs) == null ? void 0 : f.id,
      style: "display: none"
    });
  }, ue = (i, u) => {
    const p = c(i.attrs), f = i.children || null;
    return u.render("table", p, u.render("tbody", {}, f));
  }, he = (i, u) => {
    const p = c(i.attrs);
    return u.render("tr", p, i.children);
  }, de = (i, u) => {
    const { colspan: p, rowspan: f, colwidth: m, backgroundColor: k, textAlign: g, ...A } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), k && w.push(`background-color: ${k};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...A,
      ...p > 1 ? { colspan: p } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return u.render("td", I(S), i.children);
  }, pe = (i, u) => {
    const { colspan: p, rowspan: f, colwidth: m, backgroundColor: k, textAlign: g, ...A } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), k && w.push(`background-color: ${k};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...A,
      ...p > 1 ? { colspan: p } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return u.render("th", I(S), i.children);
  }, z = /* @__PURE__ */ new Map([
    [R.DOCUMENT, d("")],
    [R.HEADING, h],
    [R.PARAGRAPH, d("p")],
    [R.UL_LIST, d("ul")],
    [R.OL_LIST, d("ol")],
    [R.LIST_ITEM, d("li")],
    [R.IMAGE, v],
    [R.EMOJI, b],
    [R.CODE_BLOCK, E],
    [R.HR, d("hr")],
    [R.BR, d("br")],
    [R.QUOTE, d("blockquote")],
    [R.COMPONENT, ce],
    [Ce.TEXT, le],
    [T.LINK, V],
    [T.ANCHOR, V],
    [T.STYLED, _("span", !0)],
    [T.BOLD, _("strong")],
    [T.TEXT_STYLE, _("span", !0)],
    [T.ITALIC, _("em")],
    [T.UNDERLINE, _("u")],
    [T.STRIKE, _("s")],
    [T.CODE, _("code")],
    [T.SUPERSCRIPT, _("sup")],
    [T.SUBSCRIPT, _("sub")],
    [T.HIGHLIGHT, _("mark")],
    [R.TABLE, ue],
    [R.TABLE_ROW, he],
    [R.TABLE_CELL, de],
    [R.TABLE_HEADER, pe]
  ]), Y = new Map([...z, ...Object.entries(n).map(([i, u]) => [i, u])]), fe = () => ({
    render: (i, u = {}, p) => {
      if (l && i) {
        const f = t.get(i) || 0;
        t.set(i, f + 1), u.key = `${i}-${f}`;
      }
      return s(i, u, p);
    },
    originalResolvers: z,
    mergedResolvers: Y
  });
  function O(i) {
    const u = Y.get(i.type);
    if (!u)
      return console.error("<Storyblok>", `No resolver found for node type ${i.type}`), "";
    const p = fe();
    if (i.type === "text") return u(i, p);
    const f = i.content ? i.content.map(U) : void 0;
    return u({
      ...i,
      children: f
    }, p);
  }
  function U(i) {
    return i.type === "doc" ? a ? i.content.map(O) : i.content.map(O).join("") : Array.isArray(i) ? i.map(O) : O(i);
  }
  return { render: U };
}
let K = !1;
const W = [], Ne = (e) => new Promise((t, s) => {
  if (typeof window > "u") {
    s(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (n) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    K ? n() : W.push(n);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const r = document.createElement("script");
  r.async = !0, r.src = e, r.id = "storyblok-javascript-bridge", r.onerror = (n) => s(n), r.onload = (n) => {
    W.forEach((o) => o()), K = !0, t(n);
  }, document.getElementsByTagName("head")[0].appendChild(r);
}), B = (e = "") => e.includes("/cdn/"), He = (e, t = 25, s = 1) => ({
  ...e,
  per_page: t,
  page: s
}), Ue = (e) => new Promise((t) => setTimeout(t, e)), De = (e = 0, t) => Array.from({ length: e }, t), Be = (e = 0, t = e) => {
  const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;
  return De(s, (n, o) => o * r + e);
}, qe = async (e, t) => Promise.all(e.map(t)), Fe = (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], []), G = (e, t, s) => {
  const r = [];
  for (const n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n)) continue;
    const o = e[n];
    if (o == null) continue;
    const l = s ? "" : encodeURIComponent(n);
    let a;
    typeof o == "object" ? a = G(o, t ? t + encodeURIComponent(`[${l}]`) : l, Array.isArray(o)) : a = `${t ? t + encodeURIComponent(`[${l}]`) : l}=${encodeURIComponent(o)}`, r.push(a);
  }
  return r.join("&");
}, X = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var Ge = class {
  constructor(e) {
    y(this, "baseURL"), y(this, "timeout"), y(this, "headers"), y(this, "responseInterceptor"), y(this, "fetch"), y(this, "ejectInterceptor"), y(this, "url"), y(this, "parameters"), y(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((r) => {
      s.data = r;
    });
    for (const r of e.headers.entries()) t[r[0]] = r[1];
    return s.headers = { ...t }, s.status = e.status, s.statusText = e.statusText, s;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, s = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${G(this.parameters)}` : s = JSON.stringify(this.parameters);
    const r = new URL(t), n = new AbortController(), { signal: o } = n;
    let l = null;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${r}`, {
        method: e,
        headers: this.headers,
        body: s,
        signal: o,
        ...this.fetchOptions
      });
      this.timeout && l && clearTimeout(l);
      const c = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (a) {
      return a.name === "AbortError" ? { message: "Request timeout: The request was aborted due to timeout" } : { message: a.message || a.toString() || "An unknown error occurred" };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((s, r) => {
      if (t.test(`${e.status}`)) return s(e);
      const n = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      r(n);
    });
  }
}, Ve = Ge;
const Q = "SB-Agent", q = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, ze = {
  PUBLISHED: "published"
}, Ye = 25, F = {
  SMALL: 25,
  MEDIUM: 50,
  LARGE: 75
}, C = {
  SINGLE_OR_SMALL: 50,
  MEDIUM: 15,
  LARGE: 10,
  VERY_LARGE: 6
}, Z = 1e3, P = 3;
function Je(e, t) {
  const s = e.includes("/cdn/stories/"), r = e.split("/").length > 3 && !e.endsWith("/cdn/stories"), n = "find_by" in t;
  return s && r || n;
}
function Ke(e) {
  return e <= F.SMALL ? C.SINGLE_OR_SMALL : e <= F.MEDIUM ? C.MEDIUM : e <= F.LARGE ? C.LARGE : C.VERY_LARGE;
}
function M(e, t, s = {}, r) {
  if (s.userRateLimit !== void 0) return Math.min(s.userRateLimit, Z);
  if (s.serverHeadersRateLimit !== void 0) return Math.min(s.serverHeadersRateLimit, Z);
  if (r !== void 0) return r;
  if (!e || !t || Je(e, t)) return C.SINGLE_OR_SMALL;
  const n = t.per_page || Ye;
  return Ke(n);
}
function We(e) {
  if (!e) return null;
  const t = e["x-ratelimit"] || e["X-RateLimit"], s = e["x-ratelimit-policy"] || e["X-RateLimit-Policy"];
  if (!t && !s) return null;
  const r = {};
  if (t) {
    const n = t.match(/r=(\d+)/);
    n && (r.remaining = Number.parseInt(n[1], 10));
  }
  if (s) {
    const n = s.match(/q=(\d+)/);
    n && (r.max = Number.parseInt(n[1], 10));
  }
  return Object.keys(r).length > 0 ? r : null;
}
function Xe(e, t = !1) {
  return {
    userRateLimit: e,
    serverHeadersRateLimit: void 0,
    isManagementApi: t
  };
}
var Qe = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function Ze(e, t, s) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(s)) throw new TypeError("Expected `interval` to be a finite number");
  const r = [];
  let n = [], o = 0, l = !1;
  const a = async () => {
    o++;
    const d = r.shift();
    if (d) try {
      const h = await e(...d.args);
      d.resolve(h);
    } catch (h) {
      d.reject(h);
    }
    const v = setTimeout(() => {
      o--, r.length > 0 && a(), n = n.filter((h) => h !== v);
    }, s);
    n.includes(v) || n.push(v);
  }, c = (...d) => l ? Promise.reject(/* @__PURE__ */ new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((v, h) => {
    r.push({
      resolve: v,
      reject: h,
      args: d
    }), o < t && a();
  });
  return c.abort = () => {
    l = !0, n.forEach(clearTimeout), n = [], r.forEach((d) => d.reject(() => new Qe("Throttle function aborted"))), r.length = 0;
  }, c;
}
var et = Ze, tt = class {
  constructor(e, t = 1e3) {
    y(this, "queues"), y(this, "interval"), y(this, "throttledRequestFn"), this.queues = /* @__PURE__ */ new Map(), this.interval = t, this.throttledRequestFn = e;
  }
  /**
  * Gets or creates a throttle queue for the specified rate limit
  */
  getQueue(e) {
    let t = this.queues.get(e);
    return t || (t = et(this.throttledRequestFn, e, this.interval), this.queues.set(e, t)), t;
  }
  /**
  * Executes a request through the appropriate throttle queue based on rate limit
  */
  execute(e, ...t) {
    return this.getQueue(e)(...t);
  }
  /**
  * Aborts all throttle queues
  */
  abortAll() {
    this.queues.forEach((e) => {
      var t;
      (t = e.abort) == null || t.call(e);
    }), this.queues.clear();
  }
  /**
  * Gets the number of active queues
  */
  getQueueCount() {
    return this.queues.size;
  }
};
let N = {};
const L = {};
var st = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    y(this, "client"), y(this, "maxRetries"), y(this, "retriesDelay"), y(this, "throttleManager"), y(this, "accessToken"), y(this, "cache"), y(this, "resolveCounter"), y(this, "relations"), y(this, "links"), y(this, "version"), y(this, "rateLimitConfig"), y(this, "richTextResolver"), y(this, "resolveNestedRelations"), y(this, "stringifiedStoriesCache"), y(this, "inlineAssets");
    let s = e.endpoint || t;
    if (!s) {
      const n = e.https === !1 ? "http" : "https";
      e.oauthToken ? s = `${n}://${X(e.region)}/v1` : s = `${n}://${X(e.region)}/v2`;
    }
    const r = new Headers();
    r.set("Content-Type", "application/json"), r.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([n, o]) => {
      r.set(n, o);
    }), r.has(Q) || (r.set(Q, q.defaultAgentName), r.set(q.defaultAgentVersion, q.packageVersion)), e.oauthToken && r.set("Authorization", e.oauthToken), this.rateLimitConfig = Xe(e.rateLimit, !!e.oauthToken), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttleManager = new tt(this.throttledRequest.bind(this), 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || ze.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new Ve({
      baseURL: s,
      timeout: e.timeout || 0,
      headers: r,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = L[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return B(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, s, r, n) {
    const o = this.factoryParamOptions(e, He(t, s, r));
    return this.cacheResponse(e, o, void 0, n);
  }
  get(e, t = {}, s) {
    t || (t = {});
    const r = `/${e}`;
    B(r) && (t.version = t.version || this.version);
    const n = this.factoryParamOptions(r, t);
    return this.cacheResponse(r, n, void 0, s);
  }
  async getAll(e, t = {}, s, r) {
    const n = (t == null ? void 0 : t.per_page) || 25, o = `/${e}`.replace(/\/$/, ""), l = s ?? o.substring(o.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, c = await this.makeRequest(o, t, n, a, r), d = c.total ? Math.ceil(c.total / (c.perPage || n)) : 1, v = await qe(Be(a, d), (h) => this.makeRequest(o, t, n, h + 1, r));
    return Fe([c, ...v], (h) => Object.values(h.data[l]));
  }
  post(e, t = {}, s) {
    const r = `/${e}`, n = M(void 0, void 0, this.rateLimitConfig, P);
    return this.throttleManager.execute(n, "post", r, t, s);
  }
  put(e, t = {}, s) {
    const r = `/${e}`, n = M(void 0, void 0, this.rateLimitConfig, P);
    return this.throttleManager.execute(n, "put", r, t, s);
  }
  delete(e, t = {}, s) {
    t || (t = {});
    const r = `/${e}`, n = M(void 0, void 0, this.rateLimitConfig, P);
    return this.throttleManager.execute(n, "delete", r, t, s);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, s) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, s);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, s) {
    const r = e[t];
    r && r.fieldtype === "multilink" && r.linktype === "story" && typeof r.id == "string" && this.links[s][r.id] ? r.story = this._cleanCopy(this.links[s][r.id]) : r && r.linktype === "story" && typeof r.uuid == "string" && this.links[s][r.uuid] && (r.story = this._cleanCopy(this.links[s][r.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, s) {
    const r = e[t];
    typeof r == "string" ? e[t] = this.getStoryReference(s, r) : Array.isArray(r) && (e[t] = r.map((n) => this.getStoryReference(s, n)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, s, r) {
    if (Array.isArray(s) ? s.find((o) => o.endsWith(`.${t}`)) : s.endsWith(`.${t}`)) {
      this._resolveField(e, t, r);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(s) ? s.includes(n) : s === n) && this._resolveField(e, t, r);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, s) {
    const r = (n, o = "") => {
      if (!(!n || n._stopResolving)) {
        if (Array.isArray(n)) n.forEach((l, a) => r(l, `${o}[${a}]`));
        else if (typeof n == "object") for (const l in n) {
          const a = o ? `${o}.${l}` : l;
          (n.component && n._uid || n.type === "link") && (this._insertRelations(n, l, t, s), this._insertLinks(n, l, s)), r(n[l], a);
        }
      }
    };
    r(e.content);
  }
  async resolveLinks(e, t, s) {
    let r = [];
    if (e.link_uuids) {
      const n = e.link_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.link_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(",")
        })).data.stories.forEach((c) => {
          r.push(c);
        });
    } else r = e.links;
    r.forEach((n) => {
      this.links[s][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, s) {
    let r = [];
    if (e.rel_uuids) {
      const n = e.rel_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.rel_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c) => {
          r.push(c);
        });
      r.length > 0 && (e.rels = r, delete e.rel_uuids);
    } else r = e.rels;
    r && r.length > 0 && r.forEach((n) => {
      this.relations[s][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, s) {
    var r, n;
    let o = [];
    if (this.links[s] = {}, this.relations[s] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (o = t.resolve_relations.split(",")), await this.resolveRelations(e, t, s)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((r = e.links) != null && r.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, s), this.resolveNestedRelations) for (const l in this.relations[s]) this.iterateTree(this.relations[s][l], o, s);
    e.story ? this.iterateTree(e.story, o, s) : e.stories.forEach((l) => {
      this.iterateTree(l, o, s);
    }), this.stringifiedStoriesCache = {}, delete this.links[s], delete this.relations[s];
  }
  async cacheResponse(e, t, s, r) {
    const n = G({
      url: e,
      params: t
    }), o = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const c = await o.get(n);
      if (c) return Promise.resolve(c);
    }
    const l = !B(e) && this.rateLimitConfig.isManagementApi ? P : void 0, a = M(e, t, this.rateLimitConfig, l);
    return new Promise(async (c, d) => {
      var v;
      try {
        const h = await this.throttleManager.execute(a, "get", e, t, r);
        if (h.status !== 200) return d(h);
        let b = {
          data: h.data,
          headers: h.headers
        };
        const E = We(h.headers);
        if ((E == null ? void 0 : E.max) !== void 0 && (this.rateLimitConfig.serverHeadersRateLimit = E.max), (v = h.headers) != null && v["per-page"] && (b = Object.assign({}, b, {
          perPage: h.headers["per-page"] ? Number.parseInt(h.headers["per-page"]) : 0,
          total: h.headers["per-page"] ? Number.parseInt(h.headers.total) : 0
        })), b.data.story || b.data.stories) {
          const $ = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(b.data, t, `${$}`), b = await this.processInlineAssets(b);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await o.set(n, b);
        const _ = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && b.data.cv && (_ && L[t.token] && L[t.token] !== b.data.cv && await this.flushCache(), L[t.token] = b.data.cv), c(b);
      } catch (h) {
        if (h.response && h.status === 429 && (s = typeof s > "u" ? 0 : s + 1, s < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await Ue(this.retriesDelay), this.cacheResponse(e, t, s).then(c).catch(d);
        d(h);
      }
    });
  }
  throttledRequest(e, t, s, r) {
    return this.client.setFetchOptions(r), this.client[e](t, s);
  }
  cacheVersions() {
    return L;
  }
  cacheVersion() {
    return L[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (L[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (L[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(N[e]);
          },
          getAll() {
            return Promise.resolve(N);
          },
          set(e, t) {
            return N[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return N = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (s) => {
      if (!s || typeof s != "object") return s;
      if (Array.isArray(s)) return s.map((n) => t(n));
      let r = { ...s };
      r.fieldtype === "asset" && Array.isArray(e.data.assets) && (r = {
        ...e.data.assets.find((n) => n.id === r.id),
        ...r
      });
      for (const n in r) typeof r[n] == "object" && (r[n] = t(r[n]));
      return r;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((s) => (s.content = t(s.content), s))), e;
  }
}, rt = st;
const dt = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new rt(t) };
}, nt = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
let ee = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const ot = (e, t, s = {}) => {
  var r;
  const n = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", o = new URL((r = window.location) == null ? void 0 : r.href).searchParams.get(
    "_storyblok"
  ), l = o !== null && +o === e;
  if (!(!n || !l)) {
    if (!e) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(s).on(["input", "published", "change"], (a) => {
        var c;
        a && (a.action === "input" && ((c = a.story) == null ? void 0 : c.id) === e ? t(a.story) : (a.action === "change" || a.action === "published") && a.storyId === e && window.location.reload());
      });
    });
  }
}, it = (e = {}) => {
  var t, s;
  const {
    bridge: r,
    accessToken: n,
    use: o = [],
    apiOptions: l = {},
    bridgeUrl: a
  } = e;
  l.accessToken = l.accessToken || n;
  const c = { bridge: r, apiOptions: l };
  let d = {};
  o.forEach((h) => {
    d = { ...d, ...h(c) };
  }), a && (ee = a);
  const v = !(typeof window > "u") && ((s = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : s.includes("_storyblok_tk"));
  return r !== !1 && v && Ne(ee), d;
};
function pt(e, t) {
  return oe(t).render(e);
}
const ie = /* @__PURE__ */ te({
  __name: "StoryblokComponent",
  props: {
    blok: {}
  },
  setup(e, { expose: t }) {
    var a;
    const s = e, r = H();
    t({
      value: r
    });
    const n = typeof D(s.blok.component) != "string", o = ge("VueSDKOptions"), l = H((a = s.blok.component) == null ? void 0 : a.replace(/_/g, "-"));
    return !n && o && (o.enableFallbackComponent ? (l.value = o.customFallbackComponent ?? "FallbackComponent", typeof D(l.value) == "string" && console.error(
      `Is the Fallback component "${l.value}" registered properly?`
    )) : console.error(
      `Component could not be found for blok "${s.blok.component}"! Is it defined in main.ts as "app.component("${s.blok.component}", ${s.blok.component});"?`
    )), (c, d) => (re(), se(D(l.value), ve({
      ref_key: "blokRef",
      ref: r
    }, { ...c.$props, ...c.$attrs }), be({ _: 2 }, [
      ke(c.$slots, (v, h) => ({
        name: h,
        fn: Re((b) => [
          we(c.$slots, h, _e(Te(b)))
        ])
      }))
    ]), 1040));
  }
}), at = (e) => {
  var s;
  const t = (s = e == null ? void 0 : e.attrs) == null ? void 0 : s.body;
  return !Array.isArray(t) || t.length === 0 ? [] : t.map(
    (r) => {
      var n;
      return ne(ie, {
        blok: r,
        id: (n = e == null ? void 0 : e.attrs) == null ? void 0 : n.id
      }, e.children);
    }
  );
};
function lt(e) {
  const t = {
    renderFn: ne,
    // TODO: Check why this changed.
    // @ts-expect-error - createTextVNode types has been recently changed.
    textFn: Ae,
    keyedResolvers: !0,
    resolvers: {
      [R.COMPONENT]: at,
      ...e.resolvers
    }
  };
  return oe(t);
}
const ct = /* @__PURE__ */ te({
  __name: "StoryblokRichText",
  props: {
    doc: {},
    resolvers: {}
  },
  setup(e) {
    const t = e, s = H(), r = () => s.value;
    return Le([() => t.doc, () => t.resolvers], ([n, o]) => {
      const { render: l } = lt({
        resolvers: o ?? {}
      });
      s.value = l(n);
    }, {
      immediate: !0,
      deep: !0
    }), (n, o) => (re(), se(r));
  }
}), ut = {
  beforeMount(e, t) {
    if (t.value) {
      const s = nt(t.value);
      Object.keys(s).length > 0 && (e.setAttribute("data-blok-c", s["data-blok-c"]), e.setAttribute("data-blok-uid", s["data-blok-uid"]), e.classList.add("storyblok__outline"));
    }
  }
}, ae = (e) => {
  console.error(`You can't use ${e} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
let x = null;
const ft = () => (x || ae("useStoryblokApi"), x), mt = async (e, t = {}, s = {}) => {
  const r = H(null);
  if (s.resolveRelations = s.resolveRelations ?? t.resolve_relations, s.resolveLinks = s.resolveLinks ?? t.resolve_links, Ee(() => {
    r.value && r.value.id && ot(
      r.value.id,
      (n) => r.value = n,
      s
    );
  }), x) {
    const { data: n } = await x.get(
      `cdn/stories/${e}`,
      t
    );
    r.value = n.story;
  } else
    ae("useStoryblok");
  return r;
}, yt = {
  install(e, t = {}) {
    e.directive("editable", ut), e.component("StoryblokComponent", ie), e.component("StoryblokRichText", ct), t.enableFallbackComponent && !t.customFallbackComponent && e.component(
      "FallbackComponent",
      $e(() => import("./FallbackComponent-vpkAikkq.js"))
    );
    const { storyblokApi: s } = it(t);
    x = s || null, e.provide("VueSDKOptions", t);
  }
};
export {
  R as BlockTypes,
  T as MarkTypes,
  rt as StoryblokClient,
  ie as StoryblokComponent,
  ct as StoryblokRichText,
  yt as StoryblokVue,
  Ce as TextTypes,
  dt as apiPlugin,
  pt as renderRichText,
  oe as richTextResolver,
  mt as useStoryblok,
  ft as useStoryblokApi,
  ot as useStoryblokBridge,
  lt as useStoryblokRichText
};
