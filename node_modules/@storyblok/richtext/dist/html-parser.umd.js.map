{"version":3,"file":"html-parser.umd.js","names":["markNodePartial: Partial<MarkNode> & { type: MarkNode['type'] }","contentProcessed: StoryblokRichTextDocumentNode[]","newParagraph: StoryblokRichTextDocumentNode | null","marks: MarkNode[]","attrs: { language?: string }","defaultResolvers: Record<string, HTMLNodeElementResolver>","node: HTMLNodeText","node: HTMLNodeElement","options: Required<HTMLParserOptions>","node: HTMLNodeElement | HTMLNodeText","node: NodeHTMLParserNodeText","NodeType","tag: string","node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText","parent: HTMLNodeElement | null","elementNode: HTMLNodeElement","element: NodeHTMLParserNodeElement","defaultOptions: Required<HTMLParserOptions>","html: string","options: HTMLParserOptions"],"sources":["../src/types/index.ts","../src/utils/index.ts","../src/html-parser.ts"],"sourcesContent":["export enum BlockTypes {\n  DOCUMENT = 'doc',\n  HEADING = 'heading',\n  PARAGRAPH = 'paragraph',\n  QUOTE = 'blockquote',\n  OL_LIST = 'ordered_list',\n  UL_LIST = 'bullet_list',\n  LIST_ITEM = 'list_item',\n  CODE_BLOCK = 'code_block',\n  HR = 'horizontal_rule',\n  BR = 'hard_break',\n  IMAGE = 'image',\n  EMOJI = 'emoji',\n  COMPONENT = 'blok',\n  TABLE = 'table',\n  TABLE_ROW = 'tableRow',\n  TABLE_CELL = 'tableCell',\n  TABLE_HEADER = 'tableHeader',\n}\n\nexport enum MarkTypes {\n  BOLD = 'bold',\n  STRONG = 'strong',\n  STRIKE = 'strike',\n  UNDERLINE = 'underline',\n  ITALIC = 'italic',\n  CODE = 'code',\n  LINK = 'link',\n  ANCHOR = 'anchor',\n  STYLED = 'styled',\n  SUPERSCRIPT = 'superscript',\n  SUBSCRIPT = 'subscript',\n  TEXT_STYLE = 'textStyle',\n  HIGHLIGHT = 'highlight',\n}\n\nexport enum TextTypes {\n  TEXT = 'text',\n}\n\nexport enum LinkTargets {\n  SELF = '_self',\n  BLANK = '_blank',\n}\n\nexport enum LinkTypes {\n  URL = 'url',\n  STORY = 'story',\n  ASSET = 'asset',\n  EMAIL = 'email',\n}\n\n/**\n * Represents text alignment attributes that can be applied to block-level elements.\n */\nexport interface TextAlignmentAttrs {\n  textAlign?: 'left' | 'center' | 'right' | 'justify';\n}\n\n/**\n * Represents common attributes that can be applied to block-level elements.\n */\nexport interface BlockAttributes extends TextAlignmentAttrs {\n  class?: string;\n  id?: string;\n  [key: string]: any;\n}\n\nexport interface StoryblokRichTextDocumentNode {\n  type: string;\n  content?: StoryblokRichTextDocumentNode[];\n  attrs?: BlockAttributes;\n  text?: string;\n  marks?: StoryblokRichTextDocumentNode[];\n}\n\nexport type StoryblokRichTextNodeTypes = BlockTypes | MarkTypes | TextTypes;\n\nexport interface StoryblokRichTextNode<T = string> {\n  type: StoryblokRichTextNodeTypes;\n  content: StoryblokRichTextNode<T>[];\n  children?: T;\n  attrs?: BlockAttributes;\n  text?: string;\n}\n\nexport interface LinkNode<T = string> extends StoryblokRichTextNode<T> {\n  type: MarkTypes.LINK | MarkTypes.ANCHOR;\n  linktype: LinkTypes;\n  attrs: BlockAttributes;\n}\n\nexport interface MarkNode<T = string> extends StoryblokRichTextNode<T> {\n  type: MarkTypes.BOLD |\n    MarkTypes.ITALIC |\n    MarkTypes.UNDERLINE |\n    MarkTypes.STRIKE |\n    MarkTypes.CODE |\n    MarkTypes.LINK |\n    MarkTypes.ANCHOR |\n    MarkTypes.STYLED |\n    MarkTypes.SUPERSCRIPT |\n    MarkTypes.SUBSCRIPT |\n    MarkTypes.TEXT_STYLE |\n    MarkTypes.HIGHLIGHT;\n  attrs?: BlockAttributes;\n}\n\nexport interface TextNode<T = string> extends StoryblokRichTextNode<T> {\n  type: TextTypes.TEXT;\n  text: string;\n  marks?: MarkNode<T>[];\n}\n\n/**\n * Represents the render context provided to resolvers\n * @template T - The type of the resolved value\n */\nexport interface StoryblokRichTextContext<T = string> {\n  /**\n   * Render function that automatically handles key generation\n   * @param tag - The HTML tag to render\n   * @param attrs - The attributes for the tag\n   * @param children - Optional children content\n   */\n  render: (tag: string, attrs?: BlockAttributes, children?: T) => T;\n  /**\n   * Original resolvers map\n   */\n  originalResolvers: Map<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>;\n  /**\n   * Merged resolvers map\n   */\n  mergedResolvers: Map<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>;\n}\n\n/**\n * Represents a resolver function for a Storyblok rich text node.\n * @template T - The type of the resolved value.\n * @param node - The rich text node to resolve.\n * @param context - The render context with utilities\n * @returns The resolved value of type T.\n */\nexport type StoryblokRichTextNodeResolver<T = string> = (\n  node: StoryblokRichTextNode<T> | TextNode<T> | MarkNode<T> | LinkNode<T>,\n  context: StoryblokRichTextContext<T>\n) => T;\n\n/**\n * Represents the configuration options for optimizing images in rich text content.\n */\nexport interface StoryblokRichTextImageOptimizationOptions {\n  /**\n   * CSS class to be applied to the image.\n   */\n  class: string;\n\n  /**\n   * Width of the image in pixels.\n   */\n  width: number;\n\n  /**\n   * Height of the image in pixels.\n   */\n  height: number;\n\n  /**\n   * Loading strategy for the image. 'lazy' loads the image when it enters the viewport. 'eager' loads the image immediately.\n   */\n  loading: 'lazy' | 'eager';\n\n  /**\n   * Optional filters that can be applied to the image to adjust its appearance.\n   *\n   * @example\n   *\n   * ```typescript\n   * const filters: Partial<StoryblokRichTextImageOptimizationOptions['filters']> = {\n   *   blur: 5,\n   *   brightness: 150,\n   *   grayscale: true\n   * }\n   * ```\n   */\n  filters: Partial<{\n    blur: number;\n    brightness: number;\n    fill: 'transparent';\n    format: 'webp' | 'png' | 'jpg';\n    grayscale: boolean;\n    quality: number;\n    rotate: 0 | 90 | 180 | 270;\n  }>;\n\n  /**\n   * Defines a set of source set values that tell the browser different image sizes to load based on screen conditions.\n   * The entries can be just the width in pixels or a tuple of width and pixel density.\n   *\n   * @example\n   *\n   * ```typescript\n   * const srcset: (number | [number, number])[] = [\n   *   320,\n   *   [640, 2]\n   * ]\n   * ```\n   */\n  srcset: (number | [number, number])[];\n\n  /**\n   * A list of sizes that correspond to different viewport widths, instructing the browser on which srcset source to use.\n   *\n   * @example\n   *\n   * ```typescript\n   * const sizes: string[] = [\n   *   '(max-width: 320px) 280px',\n   *   '(max-width: 480px) 440px',\n   *   '800px'\n   * ]\n   * ```\n   */\n  sizes: string[];\n}\n\n/**\n * Resolvers for Storyblok RichText nodes.\n *\n * @template T - The type of the resolved value.\n */\nexport type StoryblokRichTextResolvers<T = string> = Partial<Record<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>>;\n\n/**\n * Represents the options for rendering rich text.\n */\nexport interface StoryblokRichTextOptions<T = string, S = (tag: string, attrs: BlockAttributes, children?: T) => T> {\n  /**\n   * Defines the function that will be used to render the final HTML string (vanilla) or Framework component (React, Vue).\n   *\n   * @example\n   *\n   * ```typescript\n   * const renderFn = (tag: string, attrs: Record<string, any>, text?: string) => {\n   *  return `<${tag} ${Object.keys(attrs).map(key => `${key}=\"${attrs[key]}\"`).join(' ')}>${text}</${tag}>`\n   * }\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn\n   * }\n   * ```\n   */\n  renderFn?: S;\n\n  /**\n   * Defines the function that will be used to render HTML text.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { h, createTextVNode } from 'vue'\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn: h,\n   *  textFn: createTextVNode\n   * }\n   * ```\n   */\n  textFn?: (text: string, attrs?: BlockAttributes) => T;\n\n  /**\n   * Defines the resolvers for each type of node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *  resolvers: {\n   *    [MarkTypes.LINK]: (node: StoryblokRichTextNode) => {\n   *      return `<a href=\"${node.attrs.href}\">${node.text}</a>`\n   *    }\n   *  }\n   * }\n   * ```\n   */\n  resolvers?: StoryblokRichTextResolvers<T>;\n\n  /**\n   * Defines opt-out image optimization options.\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *  optimizeImages: true\n   * }\n   * ```\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *    optimizeImages: {\n   *    class: 'my-image',\n   *    width: 800,\n   *    height: 600,\n   *    loading: 'lazy',\n   * }\n   * ```\n   */\n  optimizeImages?: boolean | Partial<StoryblokRichTextImageOptimizationOptions>;\n  /**\n   * Defines whether to use the key attribute in the resolvers for framework use cases.\n   * @default false\n   * @example\n   *\n   * ```typescript\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn: h,\n   *  keyedResolvers: true\n   * }\n   * ```\n   */\n  keyedResolvers?: boolean;\n}\n","import type { BlockAttributes } from '../types';\n\nexport const SELF_CLOSING_TAGS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\n\nexport const BLOCK_LEVEL_TAGS = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'canvas',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'noscript',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'tfoot',\n  'ul',\n  'video',\n];\n\n/**\n * Converts an object of attributes to a string.\n *\n * @param {Record<string, string>} [attrs]\n *\n * @returns {string} The string representation of the attributes.\n *\n * @example\n *\n * ```typescript\n * const attrs = {\n *  class: 'text-red',\n *  style: 'color: red',\n * }\n *\n * const attrsString = attrsToString(attrs)\n *\n * console.log(attrsString) // 'class=\"text-red\" style=\"color: red\"'\n *\n * ```\n *\n */\nexport const attrsToString = (attrs: BlockAttributes = {}) => {\n  const { custom, ...attrsWithoutCustom } = attrs;\n  const normalizedAttrs = { ...attrsWithoutCustom, ...custom };\n  return Object.keys(normalizedAttrs)\n    .map(key => `${key}=\"${normalizedAttrs[key]}\"`)\n    .join(' ');\n};\n\n/**\n * Converts an object of attributes to a CSS style string.\n *\n * @param {Record<string, string>} [attrs]\n *\n * @returns {string} The string representation of the CSS styles.\n *\n * @example\n *\n * ```typescript\n * const attrs = {\n *  color: 'red',\n *  fontSize: '16px',\n * }\n *\n * const styleString = attrsToStyle(attrs)\n *\n * console.log(styleString) // 'color: red; font-size: 16px'\n * ```\n */\nexport const attrsToStyle = (attrs: Record<string, string> = {}) => Object.keys(attrs)\n  .map(key => `${key}: ${attrs[key]}`)\n  .join('; ');\n\n/**\n * Escapes HTML entities in a string.\n *\n * @param {string} unsafeText\n * @return {*}  {string}\n *\n * @example\n *\n * ```typescript\n * const unsafeText = '<script>alert(\"Hello\")</script>'\n *\n * const safeText = escapeHtml(unsafeText)\n *\n * console.log(safeText) // '&lt;script&gt;alert(\"Hello\")&lt;/script&gt;'\n * ```\n */\nexport function escapeHtml(unsafeText: string): string {\n  return unsafeText\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\n/**\n * Removes undefined values from an object.\n *\n * @param {Record<string, any>} obj\n * @return {*}  {Record<string, any>}\n *\n * @example\n *\n * ```typescript\n * const obj = {\n * name: 'John',\n * age: undefined,\n * }\n *\n * const cleanedObj = cleanObject(obj)\n *\n * console.log(cleanedObj) // { name: 'John' }\n * ```\n *\n */\nexport const cleanObject = (obj: Record<string, any>) => {\n  return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined));\n};\n","import {\n  BlockTypes,\n  type MarkNode,\n  MarkTypes,\n  type StoryblokRichTextDocumentNode,\n  TextTypes,\n} from './types';\nimport {\n  type HTMLElement as NodeHTMLParserNodeElement,\n  type TextNode as NodeHTMLParserNodeText,\n  NodeType,\n  parse,\n  valid,\n} from 'node-html-parser';\nimport { BLOCK_LEVEL_TAGS, SELF_CLOSING_TAGS } from './utils';\n\nexport interface StyleOption {\n  name: string;\n  value: string;\n}\n\nexport type RichTextAttrs = Record<string, string | number | boolean | null>;\n\nexport type HTMLAttrs = Record<string, string>;\n\nexport interface HTMLParserOptions {\n  allowCustomAttributes?: boolean;\n  normalizeWhitespace?: boolean;\n  resolvers?: Record<string, HTMLNodeElementResolver>;\n  styleOptions?: StyleOption[];\n}\n\nexport interface HTMLNodeElement {\n  attrs: HTMLAttrs;\n  children?: (HTMLNodeElement | HTMLNodeText)[];\n  parent: HTMLNodeElement | null;\n  tag: keyof HTMLElementTagNameMap;\n  text: string;\n  type: 'element';\n}\n\nexport interface HTMLNodeText {\n  isLayoutWhitespace: boolean;\n  isWhitespace: boolean;\n  parent: HTMLNodeElement | null;\n  text: string;\n  type: 'text';\n}\n\nexport interface HTMLNodeElementResolverOptions {\n  allowCustomAttributes?: boolean;\n  styleOptions?: StyleOption[];\n}\n\nexport type HTMLNodeElementResolver = (\n  node: HTMLNodeElement,\n  content: StoryblokRichTextDocumentNode[] | undefined,\n  options: HTMLNodeElementResolverOptions\n) => StoryblokRichTextDocumentNode | StoryblokRichTextDocumentNode[] | null;\n\nexport const HTMLTags = {\n  H1: 'h1',\n  H2: 'h2',\n  H3: 'h3',\n  H4: 'h4',\n  H5: 'h5',\n  H6: 'h6',\n  P: 'p',\n  OL: 'ol',\n  UL: 'ul',\n  LI: 'li',\n  TABLE: 'table',\n  THEAD: 'thead',\n  TBODY: 'tbody',\n  TR: 'tr',\n  TH: 'th',\n  TD: 'td',\n  BLOCKQUOTE: 'blockquote',\n  PRE: 'pre',\n  SPAN: 'span',\n  STRONG: 'strong',\n  B: 'b',\n  EM: 'em',\n  I: 'i',\n  A: 'a',\n  DEL: 'del',\n  S: 's',\n  CODE: 'code',\n  IMG: 'img',\n  HR: 'hr',\n  BR: 'br',\n};\n\nconst tagMap = {\n  [HTMLTags.H1]: BlockTypes.HEADING,\n  [HTMLTags.H2]: BlockTypes.HEADING,\n  [HTMLTags.H3]: BlockTypes.HEADING,\n  [HTMLTags.H4]: BlockTypes.HEADING,\n  [HTMLTags.H5]: BlockTypes.HEADING,\n  [HTMLTags.H6]: BlockTypes.HEADING,\n  [HTMLTags.P]: BlockTypes.PARAGRAPH,\n  [HTMLTags.OL]: BlockTypes.OL_LIST,\n  [HTMLTags.UL]: BlockTypes.UL_LIST,\n  [HTMLTags.LI]: BlockTypes.LIST_ITEM,\n  [HTMLTags.BLOCKQUOTE]: BlockTypes.QUOTE,\n  [HTMLTags.PRE]: BlockTypes.CODE_BLOCK,\n  [HTMLTags.TABLE]: BlockTypes.TABLE,\n  [HTMLTags.THEAD]: BlockTypes.TABLE_HEADER,\n  [HTMLTags.TR]: BlockTypes.TABLE_ROW,\n  [HTMLTags.TH]: BlockTypes.TABLE_CELL,\n  [HTMLTags.TD]: BlockTypes.TABLE_CELL,\n  [HTMLTags.IMG]: BlockTypes.IMAGE,\n  [HTMLTags.HR]: BlockTypes.HR,\n  [HTMLTags.BR]: BlockTypes.BR,\n} as const;\n\nfunction createMark(markNodePartial: Partial<MarkNode> & { type: MarkNode['type'] }): MarkNode {\n  return {\n    ...markNodePartial,\n    content: [],\n  };\n}\n\nfunction resolveBlock({\n  attrs,\n  marks,\n}: {\n  attrs?: RichTextAttrs;\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content) => {\n    const unsupportedAttributes = Object.keys(node.attrs).filter(attr => !attrs?.[attr]);\n    for (const attr of unsupportedAttributes) {\n      console.warn(`[StoryblokRichText] - \\`${attr}\\` \"${node.attrs[attr]}\" on \\`<${node.tag}>\\` can not be transformed to rich text.`);\n    }\n\n    return {\n      type: tagMap[node.tag],\n      content,\n      attrs,\n      marks,\n    };\n  };\n}\n\nfunction resolveBlockWithParagraphWrappers({\n  attrs,\n  marks,\n}: {\n  attrs?: RichTextAttrs;\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content = [], options) => {\n    const contentProcessed: StoryblokRichTextDocumentNode[] = [];\n    let newParagraph: StoryblokRichTextDocumentNode | null = null;\n\n    for (const child of content) {\n      // 1. Wrap text nodes in a paragraph\n      if (child.type === TextTypes.TEXT) {\n        if (!newParagraph) {\n          newParagraph = { type: BlockTypes.PARAGRAPH, content: [] };\n        }\n        newParagraph.content?.push(child);\n      }\n\n      if (child.type !== TextTypes.TEXT) {\n        // 2. If a text node is followed by a non-text node, push the paragraph\n        if (newParagraph) {\n          contentProcessed.push(newParagraph);\n          newParagraph = null;\n        }\n        contentProcessed.push(child);\n      }\n    }\n\n    // 3. If there's a pending paragraph, push it\n    if (newParagraph) {\n      contentProcessed.push(newParagraph);\n    }\n\n    return resolveBlock({ attrs, marks })(node, contentProcessed, options);\n  };\n}\n\nfunction resolveText({\n  marks: extraMarks = [],\n}: {\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content = [], { styleOptions }) => {\n    const marks: MarkNode[] = [...extraMarks];\n    const nodeStyles = node.attrs.class ? node.attrs.class.split(' ') : [];\n    const allowedStyles = styleOptions?.map(opt => opt.value) ?? [];\n    const styles = allowedStyles.filter(x => nodeStyles.includes(x));\n    if (styles.length > 0) {\n      marks.push(createMark({\n        type: MarkTypes.STYLED,\n        attrs: {\n          class: styles.join(' '),\n        },\n      }));\n    }\n    const removedStyles = nodeStyles.filter(x => !allowedStyles.includes(x));\n    for (const removedStyle of removedStyles) {\n      console.warn(`[StoryblokRichText] - \\`class\\` \"${removedStyle}\" on \\`<${node.tag}>\\` can not be transformed to rich text.`);\n    }\n\n    // Apply marks to child text nodes, preserving any existing marks\n    return content.map((child) => {\n      if (child.type === TextTypes.TEXT) {\n        if (marks.length === 0) {\n          return child;\n        }\n        const allMarks = child.marks ? [...child.marks, ...marks] : marks;\n        return { ...child, marks: allMarks };\n      }\n      return child;\n    });\n  };\n}\n\nfunction resolveCode(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    // We treat <code> tags separately if they're in <pre> tags\n    if (node.parent?.tag === HTMLTags.PRE) {\n      return null;\n    }\n\n    return resolveText({ marks: [createMark({ type: MarkTypes.CODE })] })(node, content, options);\n  };\n}\n\nfunction resolveHeading(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const levelMatch = node.tag.match(/h(\\d)/);\n    if (!levelMatch) {\n      throw new Error('Invalid heading tag!');\n    }\n\n    const level = Number(levelMatch[1]);\n    return resolveBlock({\n      attrs: { level },\n    })(node, content, options);\n  };\n}\n\nfunction resolveTableCell(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const attrs = {\n      colspan: node.attrs.colspan ?? 1,\n      rowspan: node.attrs.rowspan ?? 1,\n      colwidth: node.attrs.colwidth ?? null,\n    };\n\n    return resolveBlockWithParagraphWrappers({ attrs })(node, content, options);\n  };\n}\n\nfunction resolvePre(): HTMLNodeElementResolver {\n  return (node, _, options) => {\n    if (node.children && node.children.length > 1) {\n      throw new Error('Multiple child nodes within `<pre>` are not allowed!');\n    }\n\n    const attrs: { language?: string } = {};\n    const child = node.children?.[0];\n    if (!child) {\n      return resolveBlock({ attrs })(node, [], options);\n    }\n\n    const text = child.text;\n    if (child.type === 'element' && child.tag === HTMLTags.CODE) {\n      const languageMatch = child.attrs.class?.match(/(?:^|\\s)language-([\\w-]+)(?:\\s|$)/);\n      if (languageMatch) {\n        attrs.language = languageMatch[1];\n      }\n    }\n    const content = [{ type: TextTypes.TEXT, text }];\n\n    return resolveBlock({ attrs })(node, content, options);\n  };\n}\n\nfunction resolveAnchor(): HTMLNodeElementResolver {\n  return (node, content, { allowCustomAttributes, styleOptions }) => {\n    const {\n      href,\n      target,\n      id,\n      ...custom\n    }: { href?: string; target?: string; id?: string } & Record<\n      string,\n      string\n    > = node.attrs;\n    const type = !href && id ? MarkTypes.ANCHOR : MarkTypes.LINK;\n    const mark = createMark({\n      type,\n      attrs: {\n        href,\n        target,\n        anchor: id,\n        custom: allowCustomAttributes && Object.keys(custom).length > 0 ? custom : undefined,\n      },\n    });\n\n    return resolveText({ marks: [mark] })(node, content, { allowCustomAttributes, styleOptions });\n  };\n}\n\nfunction resolveImage(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const {\n      src,\n      alt,\n      title,\n    }: { src?: string; alt?: string; title?: string } & Record<\n      string,\n      string\n    > = node.attrs;\n    const attrs = {\n      src,\n      alt,\n      title,\n    };\n\n    return resolveBlock({ attrs })(node, content, options);\n  };\n}\n\nfunction resolveContentOnly(): HTMLNodeElementResolver {\n  return (_, content) => {\n    return content || null;\n  };\n}\n\n/**\n * Default resolvers for supported HTML tags.\n */\nconst defaultResolvers: Record<string, HTMLNodeElementResolver> = {\n  // Block-level elements\n  [HTMLTags.H1]: resolveHeading(),\n  [HTMLTags.H2]: resolveHeading(),\n  [HTMLTags.H3]: resolveHeading(),\n  [HTMLTags.H4]: resolveHeading(),\n  [HTMLTags.H5]: resolveHeading(),\n  [HTMLTags.H6]: resolveHeading(),\n  [HTMLTags.P]: resolveBlock(),\n  [HTMLTags.OL]: resolveBlock(),\n  [HTMLTags.UL]: resolveBlock(),\n  [HTMLTags.LI]: resolveBlockWithParagraphWrappers(),\n  [HTMLTags.BLOCKQUOTE]: resolveBlockWithParagraphWrappers(),\n  [HTMLTags.PRE]: resolvePre(),\n  [HTMLTags.TABLE]: resolveBlock(),\n  [HTMLTags.THEAD]: resolveContentOnly(),\n  [HTMLTags.TBODY]: resolveContentOnly(),\n  [HTMLTags.TR]: resolveBlock(),\n  [HTMLTags.TH]: resolveTableCell(),\n  [HTMLTags.TD]: resolveTableCell(),\n\n  // Inline elements\n  [HTMLTags.SPAN]: resolveText(),\n  [HTMLTags.STRONG]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),\n  [HTMLTags.B]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),\n  [HTMLTags.EM]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),\n  [HTMLTags.I]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),\n  [HTMLTags.A]: resolveAnchor(),\n  [HTMLTags.DEL]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),\n  [HTMLTags.S]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),\n  [HTMLTags.CODE]: resolveCode(),\n\n  // Self-closing tags\n  [HTMLTags.IMG]: resolveImage(),\n  [HTMLTags.HR]: resolveBlock(),\n  [HTMLTags.BR]: resolveBlock(),\n};\n\nfunction textToRichTextNode(node: HTMLNodeText) {\n  return {\n    type: TextTypes.TEXT,\n    text: node.text,\n  } satisfies StoryblokRichTextDocumentNode;\n}\n\nfunction elementToRichTextNode(node: HTMLNodeElement, options: Required<HTMLParserOptions>) {\n  const resolver = options.resolvers[node.tag];\n  if (!resolver) {\n    throw new Error(`No resolver specified for tag \"${node.tag}\"!`);\n  }\n\n  const children = (node.children || [])\n    .map(n => toRichTextNode(n, options))\n    .flat()\n    .filter(c => c !== null);\n\n  return resolver(node, children, options);\n}\n\nfunction removeWhitespaceFromNode(node: HTMLNodeElement | HTMLNodeText) {\n  const nodeProcessed = { ...node };\n  // Remove node if it is not affecting rendering\n  const isUnnecessaryWhitespace = nodeProcessed.type === 'text' && nodeProcessed.isWhitespace && !nodeProcessed.isLayoutWhitespace;\n  if (isUnnecessaryWhitespace) {\n    return null;\n  }\n\n  // Replace newlines with spaces except within tags with preformatted text\n  const hasFormattedText = 'tag' in nodeProcessed && ['pre', 'textarea', 'script', 'style'].includes(nodeProcessed.tag);\n  if (!hasFormattedText) {\n    nodeProcessed.text = nodeProcessed.text.replace(/(\\r\\n|\\n|\\r)/g, ' ');\n  }\n\n  return nodeProcessed;\n}\n\n/**\n * Converts a node to a Rich Text node.\n */\nfunction toRichTextNode(\n  node: HTMLNodeElement | HTMLNodeText,\n  options: Required<HTMLParserOptions>,\n): StoryblokRichTextDocumentNode | StoryblokRichTextDocumentNode[] | null {\n  let nodeProcessed = { ...node };\n  if (options.normalizeWhitespace) {\n    const normalizedNode = removeWhitespaceFromNode(node);\n    if (!normalizedNode) {\n      return null;\n    }\n\n    nodeProcessed = normalizedNode;\n  }\n\n  if (nodeProcessed.type === 'text') {\n    return textToRichTextNode(nodeProcessed);\n  }\n\n  return elementToRichTextNode(nodeProcessed, options);\n}\n\nfunction getPreviousElementSibling(node: NodeHTMLParserNodeText): NodeHTMLParserNodeElement | null {\n  const index = node.parentNode.childNodes.indexOf(node);\n  const previousSibling = node.parentNode.childNodes[index - 1];\n  if (!previousSibling) {\n    return null;\n  }\n\n  if (previousSibling.nodeType !== NodeType.ELEMENT_NODE) {\n    return getPreviousElementSibling(previousSibling as NodeHTMLParserNodeText);\n  }\n\n  return previousSibling as NodeHTMLParserNodeElement;\n}\n\nfunction getNextElementSibling(node: NodeHTMLParserNodeText): NodeHTMLParserNodeElement | null {\n  const index = node.parentNode.childNodes.indexOf(node);\n  const nextSibling = node.parentNode.childNodes[index + 1];\n  if (!nextSibling) {\n    return null;\n  }\n\n  if (nextSibling.nodeType !== NodeType.ELEMENT_NODE) {\n    return getNextElementSibling(nextSibling as NodeHTMLParserNodeText);\n  }\n\n  return nextSibling as NodeHTMLParserNodeElement;\n}\n\nconst tagsNotRequiringWhitespace = [...BLOCK_LEVEL_TAGS, ...SELF_CLOSING_TAGS];\nfunction tagRequiresWhitespace(tag: string) {\n  return !tagsNotRequiringWhitespace.includes(tag.toLowerCase());\n}\n\n/**\n * Adapts a `node-html-parse` node to a custom parser node format.\n * We don't want to expose the `node-html-parse` types directly, so this\n * function adapts the nodes to our custom format.\n */\nfunction adaptParserNode(node: NodeHTMLParserNodeElement, parent?: HTMLNodeElement | null): HTMLNodeElement;\nfunction adaptParserNode(node: NodeHTMLParserNodeText, parent?: HTMLNodeElement | null): HTMLNodeText;\nfunction adaptParserNode(node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText, parent?: HTMLNodeElement | null): HTMLNodeElement | HTMLNodeText;\nfunction adaptParserNode(\n  node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText,\n  parent: HTMLNodeElement | null = null,\n): HTMLNodeElement | HTMLNodeText {\n  if ('trimmedRawText' in node) {\n    const previousElementSibling = getPreviousElementSibling(node);\n    const previousSiblingRequiresWhitespace = !previousElementSibling || tagRequiresWhitespace(previousElementSibling.tagName);\n    const nextElementSibling = getNextElementSibling(node);\n    const nextSiblingRequiresWhitespace = !nextElementSibling || tagRequiresWhitespace(nextElementSibling.tagName);\n    const isLayoutWhitespace = node.isWhitespace && (previousSiblingRequiresWhitespace || nextSiblingRequiresWhitespace);\n\n    return {\n      type: 'text',\n      text: node.text,\n      parent,\n      isWhitespace: node.isWhitespace,\n      isLayoutWhitespace,\n    } satisfies HTMLNodeText;\n  }\n\n  const elementNode: HTMLNodeElement = {\n    type: 'element',\n    tag: node.tagName.toLowerCase() as keyof HTMLElementTagNameMap,\n    text: node.text,\n    attrs: node.attributes,\n    parent,\n  };\n  elementNode.children = node.childNodes.map(child =>\n    adaptParserNode(child as NodeHTMLParserNodeElement | NodeHTMLParserNodeText, elementNode),\n  );\n\n  return elementNode;\n}\n\n/**\n * The rich text format does not support elements nested inside of anchors. For\n * simpler transformation logic, we transform the HTML tree beforehand to\n * accommodate this limitation.\n *\n * For example, the structure:\n * `<p>Please <a>click <b>here</b> for more</a> info.</p>`\n * will be transformed into:\n * `<p>Please <a>click </a><b><a>here</a></b><a> for more</a> info.</p>`\n *\n * @param element The `NodeHTMLParserNodeElement` to search for and normalize links within.\n * @throws {Error} Throws an error if a nested element within an anchor contains non-text nodes.\n */\nfunction normalizeLinks(element: NodeHTMLParserNodeElement) {\n  for (const anchor of element.querySelectorAll('a')) {\n    const hasOnlyTextNodes = !anchor.childNodes.some(c => c.nodeType === NodeType.ELEMENT_NODE);\n    if (hasOnlyTextNodes) {\n      continue;\n    }\n\n    const normalizedLinks = [];\n    for (const child of anchor.childNodes) {\n      if (child.nodeType === NodeType.TEXT_NODE) {\n        const a = anchor.clone();\n        a.childNodes.forEach(c => c.remove());\n        // @ts-expect-error node-html-parser types are wrong\n        a.appendChild(child);\n        normalizedLinks.push(a);\n        continue;\n      }\n\n      for (const text of child.childNodes) {\n        if (text.nodeType !== NodeType.TEXT_NODE) {\n          throw new Error('Non-text nodes within anchors are not supported!');\n        }\n        const a = anchor.clone();\n        a.childNodes.forEach(c => c.remove());\n        // @ts-expect-error node-html-parser types are wrong\n        a.appendChild(text);\n        // @ts-expect-error node-html-parser types are wrong\n        child.appendChild(a);\n      }\n      normalizedLinks.push(child);\n    }\n    anchor.replaceWith(...normalizedLinks);\n  }\n}\n\nexport const defaultOptions: Required<HTMLParserOptions> = {\n  allowCustomAttributes: false,\n  normalizeWhitespace: true,\n  resolvers: defaultResolvers,\n  styleOptions: [],\n} as const;\n\n/**\n * Convert HTML to Storyblok Rich Text format.\n */\nexport function htmlToStoryblokRichtext(\n  html: string,\n  options: HTMLParserOptions = {},\n): StoryblokRichTextDocumentNode {\n  if (!valid(html)) {\n    throw new Error('Invalid HTML: The provided string could not be parsed. Common causes include unclosed or mismatched tags!');\n  }\n\n  const root = parse(html, { blockTextElements: {} });\n  normalizeLinks(root);\n\n  const content = root.childNodes\n    .map(parserNode =>\n      toRichTextNode(adaptParserNode(parserNode as NodeHTMLParserNodeElement | NodeHTMLParserNodeText), {\n        ...defaultOptions,\n        ...options,\n        resolvers: {\n          ...defaultOptions.resolvers,\n          ...options.resolvers,\n        },\n      }),\n    )\n    .flat()\n    .filter(c => c !== null);\n\n  return {\n    type: 'doc',\n    content,\n  };\n}\n"],"mappings":"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"}