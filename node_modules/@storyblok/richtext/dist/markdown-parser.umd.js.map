{"version":3,"file":"markdown-parser.umd.js","names":["nodes: StoryblokRichTextDocumentNode[] | undefined","mark: { type: string; attrs?: Record<string, unknown> | null }","defaultResolvers: Record<string, MarkdownNodeResolver>","markdown: string","options: MarkdownParserOptions","MarkdownIt","tokens: MarkdownToken[]","nodes: StoryblokRichTextDocumentNode[]","tokens","children: StoryblokRichTextDocumentNode[]"],"sources":["../src/types/index.ts","../src/markdown-parser.ts"],"sourcesContent":["export enum BlockTypes {\n  DOCUMENT = 'doc',\n  HEADING = 'heading',\n  PARAGRAPH = 'paragraph',\n  QUOTE = 'blockquote',\n  OL_LIST = 'ordered_list',\n  UL_LIST = 'bullet_list',\n  LIST_ITEM = 'list_item',\n  CODE_BLOCK = 'code_block',\n  HR = 'horizontal_rule',\n  BR = 'hard_break',\n  IMAGE = 'image',\n  EMOJI = 'emoji',\n  COMPONENT = 'blok',\n  TABLE = 'table',\n  TABLE_ROW = 'tableRow',\n  TABLE_CELL = 'tableCell',\n  TABLE_HEADER = 'tableHeader',\n}\n\nexport enum MarkTypes {\n  BOLD = 'bold',\n  STRONG = 'strong',\n  STRIKE = 'strike',\n  UNDERLINE = 'underline',\n  ITALIC = 'italic',\n  CODE = 'code',\n  LINK = 'link',\n  ANCHOR = 'anchor',\n  STYLED = 'styled',\n  SUPERSCRIPT = 'superscript',\n  SUBSCRIPT = 'subscript',\n  TEXT_STYLE = 'textStyle',\n  HIGHLIGHT = 'highlight',\n}\n\nexport enum TextTypes {\n  TEXT = 'text',\n}\n\nexport enum LinkTargets {\n  SELF = '_self',\n  BLANK = '_blank',\n}\n\nexport enum LinkTypes {\n  URL = 'url',\n  STORY = 'story',\n  ASSET = 'asset',\n  EMAIL = 'email',\n}\n\n/**\n * Represents text alignment attributes that can be applied to block-level elements.\n */\nexport interface TextAlignmentAttrs {\n  textAlign?: 'left' | 'center' | 'right' | 'justify';\n}\n\n/**\n * Represents common attributes that can be applied to block-level elements.\n */\nexport interface BlockAttributes extends TextAlignmentAttrs {\n  class?: string;\n  id?: string;\n  [key: string]: any;\n}\n\nexport interface StoryblokRichTextDocumentNode {\n  type: string;\n  content?: StoryblokRichTextDocumentNode[];\n  attrs?: BlockAttributes;\n  text?: string;\n  marks?: StoryblokRichTextDocumentNode[];\n}\n\nexport type StoryblokRichTextNodeTypes = BlockTypes | MarkTypes | TextTypes;\n\nexport interface StoryblokRichTextNode<T = string> {\n  type: StoryblokRichTextNodeTypes;\n  content: StoryblokRichTextNode<T>[];\n  children?: T;\n  attrs?: BlockAttributes;\n  text?: string;\n}\n\nexport interface LinkNode<T = string> extends StoryblokRichTextNode<T> {\n  type: MarkTypes.LINK | MarkTypes.ANCHOR;\n  linktype: LinkTypes;\n  attrs: BlockAttributes;\n}\n\nexport interface MarkNode<T = string> extends StoryblokRichTextNode<T> {\n  type: MarkTypes.BOLD |\n    MarkTypes.ITALIC |\n    MarkTypes.UNDERLINE |\n    MarkTypes.STRIKE |\n    MarkTypes.CODE |\n    MarkTypes.LINK |\n    MarkTypes.ANCHOR |\n    MarkTypes.STYLED |\n    MarkTypes.SUPERSCRIPT |\n    MarkTypes.SUBSCRIPT |\n    MarkTypes.TEXT_STYLE |\n    MarkTypes.HIGHLIGHT;\n  attrs?: BlockAttributes;\n}\n\nexport interface TextNode<T = string> extends StoryblokRichTextNode<T> {\n  type: TextTypes.TEXT;\n  text: string;\n  marks?: MarkNode<T>[];\n}\n\n/**\n * Represents the render context provided to resolvers\n * @template T - The type of the resolved value\n */\nexport interface StoryblokRichTextContext<T = string> {\n  /**\n   * Render function that automatically handles key generation\n   * @param tag - The HTML tag to render\n   * @param attrs - The attributes for the tag\n   * @param children - Optional children content\n   */\n  render: (tag: string, attrs?: BlockAttributes, children?: T) => T;\n  /**\n   * Original resolvers map\n   */\n  originalResolvers: Map<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>;\n  /**\n   * Merged resolvers map\n   */\n  mergedResolvers: Map<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>;\n}\n\n/**\n * Represents a resolver function for a Storyblok rich text node.\n * @template T - The type of the resolved value.\n * @param node - The rich text node to resolve.\n * @param context - The render context with utilities\n * @returns The resolved value of type T.\n */\nexport type StoryblokRichTextNodeResolver<T = string> = (\n  node: StoryblokRichTextNode<T> | TextNode<T> | MarkNode<T> | LinkNode<T>,\n  context: StoryblokRichTextContext<T>\n) => T;\n\n/**\n * Represents the configuration options for optimizing images in rich text content.\n */\nexport interface StoryblokRichTextImageOptimizationOptions {\n  /**\n   * CSS class to be applied to the image.\n   */\n  class: string;\n\n  /**\n   * Width of the image in pixels.\n   */\n  width: number;\n\n  /**\n   * Height of the image in pixels.\n   */\n  height: number;\n\n  /**\n   * Loading strategy for the image. 'lazy' loads the image when it enters the viewport. 'eager' loads the image immediately.\n   */\n  loading: 'lazy' | 'eager';\n\n  /**\n   * Optional filters that can be applied to the image to adjust its appearance.\n   *\n   * @example\n   *\n   * ```typescript\n   * const filters: Partial<StoryblokRichTextImageOptimizationOptions['filters']> = {\n   *   blur: 5,\n   *   brightness: 150,\n   *   grayscale: true\n   * }\n   * ```\n   */\n  filters: Partial<{\n    blur: number;\n    brightness: number;\n    fill: 'transparent';\n    format: 'webp' | 'png' | 'jpg';\n    grayscale: boolean;\n    quality: number;\n    rotate: 0 | 90 | 180 | 270;\n  }>;\n\n  /**\n   * Defines a set of source set values that tell the browser different image sizes to load based on screen conditions.\n   * The entries can be just the width in pixels or a tuple of width and pixel density.\n   *\n   * @example\n   *\n   * ```typescript\n   * const srcset: (number | [number, number])[] = [\n   *   320,\n   *   [640, 2]\n   * ]\n   * ```\n   */\n  srcset: (number | [number, number])[];\n\n  /**\n   * A list of sizes that correspond to different viewport widths, instructing the browser on which srcset source to use.\n   *\n   * @example\n   *\n   * ```typescript\n   * const sizes: string[] = [\n   *   '(max-width: 320px) 280px',\n   *   '(max-width: 480px) 440px',\n   *   '800px'\n   * ]\n   * ```\n   */\n  sizes: string[];\n}\n\n/**\n * Resolvers for Storyblok RichText nodes.\n *\n * @template T - The type of the resolved value.\n */\nexport type StoryblokRichTextResolvers<T = string> = Partial<Record<StoryblokRichTextNodeTypes, StoryblokRichTextNodeResolver<T>>>;\n\n/**\n * Represents the options for rendering rich text.\n */\nexport interface StoryblokRichTextOptions<T = string, S = (tag: string, attrs: BlockAttributes, children?: T) => T> {\n  /**\n   * Defines the function that will be used to render the final HTML string (vanilla) or Framework component (React, Vue).\n   *\n   * @example\n   *\n   * ```typescript\n   * const renderFn = (tag: string, attrs: Record<string, any>, text?: string) => {\n   *  return `<${tag} ${Object.keys(attrs).map(key => `${key}=\"${attrs[key]}\"`).join(' ')}>${text}</${tag}>`\n   * }\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn\n   * }\n   * ```\n   */\n  renderFn?: S;\n\n  /**\n   * Defines the function that will be used to render HTML text.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { h, createTextVNode } from 'vue'\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn: h,\n   *  textFn: createTextVNode\n   * }\n   * ```\n   */\n  textFn?: (text: string, attrs?: BlockAttributes) => T;\n\n  /**\n   * Defines the resolvers for each type of node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *  resolvers: {\n   *    [MarkTypes.LINK]: (node: StoryblokRichTextNode) => {\n   *      return `<a href=\"${node.attrs.href}\">${node.text}</a>`\n   *    }\n   *  }\n   * }\n   * ```\n   */\n  resolvers?: StoryblokRichTextResolvers<T>;\n\n  /**\n   * Defines opt-out image optimization options.\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *  optimizeImages: true\n   * }\n   * ```\n   *\n   * @example\n   *\n   * ```typescript\n   * const options: StoryblokRichTextOptions = {\n   *    optimizeImages: {\n   *    class: 'my-image',\n   *    width: 800,\n   *    height: 600,\n   *    loading: 'lazy',\n   * }\n   * ```\n   */\n  optimizeImages?: boolean | Partial<StoryblokRichTextImageOptimizationOptions>;\n  /**\n   * Defines whether to use the key attribute in the resolvers for framework use cases.\n   * @default false\n   * @example\n   *\n   * ```typescript\n   *\n   * const options: StoryblokRichTextOptions = {\n   *  renderFn: h,\n   *  keyedResolvers: true\n   * }\n   * ```\n   */\n  keyedResolvers?: boolean;\n}\n","import MarkdownIt from 'markdown-it';\nimport { BlockTypes, MarkTypes, type StoryblokRichTextDocumentNode, TextTypes } from './types';\n\n/**\n * markdown-it Token interface definition\n */\nexport interface MarkdownToken {\n  type: string;\n  tag: string;\n  attrs: Array<[string, string]> | null;\n  map: [number, number] | null;\n  nesting: 1 | 0 | -1;\n  level: number;\n  children: MarkdownToken[] | null;\n  content: string;\n  markup: string;\n  info: string;\n  meta: any;\n  block: boolean;\n  hidden: boolean;\n  attrGet: (name: string) => string | null;\n  attrSet: (name: string, value: string) => void;\n  attrPush: (attrData: [string, string]) => void;\n  attrJoin: (name: string, value: string) => void;\n  attrIndex: (name: string) => number;\n}\n\n/**\n * Type for a Markdown element resolver.\n */\nexport type MarkdownNodeResolver = (\n  token: MarkdownToken,\n  children: StoryblokRichTextDocumentNode[] | undefined\n) => StoryblokRichTextDocumentNode | null;\n\n/**\n * Options for the markdown parser, allowing custom resolvers.\n */\nexport interface MarkdownParserOptions {\n  resolvers?: Partial<Record<string, MarkdownNodeResolver>>;\n}\n\n/**\n * Supported Markdown token types as constants for maintainability and type safety.\n * @see https://markdown-it.github.io/token-class.html\n */\nexport const MarkdownTokenTypes = {\n  HEADING: 'heading_open',\n  PARAGRAPH: 'paragraph_open',\n  TEXT: 'text',\n  STRONG: 'strong_open',\n  EMP: 'em_open',\n  ORDERED_LIST: 'ordered_list_open',\n  BULLET_LIST: 'bullet_list_open',\n  LIST_ITEM: 'list_item_open',\n  IMAGE: 'image',\n  BLOCKQUOTE: 'blockquote_open',\n  CODE_INLINE: 'code_inline',\n  CODE_BLOCK: 'code_block',\n  FENCE: 'fence',\n  LINK: 'link_open',\n  HR: 'hr',\n  DEL: 'del_open',\n  HARD_BREAK: 'hardbreak',\n  SOFT_BREAK: 'softbreak',\n  TABLE: 'table_open',\n  THEAD: 'thead_open',\n  TBODY: 'tbody_open',\n  TR: 'tr_open',\n  TH: 'th_open',\n  TD: 'td_open',\n  S: 's_open',\n} as const;\n\nexport type MarkdownTokenType = keyof typeof MarkdownTokenTypes;\n\n/**\n * Mark all text nodes in-place (including nested inline content).\n */\nfunction applyMarkInPlace(\n  nodes: StoryblokRichTextDocumentNode[] | undefined,\n  mark: { type: string; attrs?: Record<string, unknown> | null },\n) {\n  if (!nodes) {\n    return;\n  }\n\n  for (const node of nodes) {\n    // If weâ€™re applying a mark (bold/italic/strike) and encounter a link node,\n    // flatten it: apply link mark first, then the outer mark, then replace the\n    // link wrapper with its content.\n    if (node.type === MarkTypes.LINK && Array.isArray(node.content)) {\n      const linkMark = { type: MarkTypes.LINK, attrs: node.attrs ?? null };\n\n      // Apply link first to ensure expected order [link, <outer mark>]\n      applyMarkInPlace(node.content, linkMark);\n      applyMarkInPlace(node.content, mark);\n\n      // Replace the link node with its now-marked children\n      nodes.splice(nodes.indexOf(node), 1, ...node.content);\n      continue;\n    }\n\n    const existing = (node.marks || []) as Array<any>;\n    node.marks = [...existing, mark];\n  }\n}\n\n/**\n * Default resolvers for supported Markdown token types.\n * These map markdown-it tokens to Storyblok RichText nodes.\n */\nconst defaultResolvers: Record<string, MarkdownNodeResolver> = {\n  [MarkdownTokenTypes.HEADING]: (token, children) => {\n    // Heading level is in token.tag (e.g., 'h1', 'h2', ...)\n    const level = Number(token.tag.replace('h', ''));\n    return {\n      type: BlockTypes.HEADING,\n      attrs: { level },\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.PARAGRAPH]: (_token, children) => {\n    return {\n      type: BlockTypes.PARAGRAPH,\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.TEXT]: (token) => {\n    // Skip empty text nodes\n    if (!token.content || token.content.trim() === '') {\n      return null;\n    }\n    return {\n      type: TextTypes.TEXT,\n      text: token.content,\n    };\n  },\n  [MarkdownTokenTypes.STRONG]: (_token, children) => {\n    applyMarkInPlace(children, { type: MarkTypes.BOLD });\n    return null; // flatten children\n  },\n  [MarkdownTokenTypes.EMP]: (_token, children) => {\n    applyMarkInPlace(children, { type: MarkTypes.ITALIC });\n    return null; // flatten children\n  },\n  [MarkdownTokenTypes.ORDERED_LIST]: (_token, children) => {\n    return {\n      type: BlockTypes.OL_LIST,\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.BULLET_LIST]: (_token, children) => {\n    return {\n      type: BlockTypes.UL_LIST,\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.LIST_ITEM]: (_token, children) => {\n    return {\n      type: BlockTypes.LIST_ITEM,\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.IMAGE]: (token) => {\n    return {\n      type: BlockTypes.IMAGE,\n      attrs: {\n        src: token.attrGet('src'),\n        alt: token.content || token.attrGet('alt') || '',\n        title: token.attrGet('title') || '',\n      },\n    };\n  },\n  [MarkdownTokenTypes.BLOCKQUOTE]: (_token, children) => {\n    return {\n      type: BlockTypes.QUOTE,\n      content: children,\n    };\n  },\n  [MarkdownTokenTypes.CODE_INLINE]: (token) => {\n    return {\n      type: MarkTypes.CODE,\n      text: token.content,\n      marks: [{ type: MarkTypes.CODE }],\n    };\n  },\n  [MarkdownTokenTypes.CODE_BLOCK]: (token) => {\n    return {\n      type: BlockTypes.CODE_BLOCK,\n      attrs: {\n        language: null,\n      },\n      content: [\n        {\n          type: 'text',\n          text: token.content,\n        },\n      ],\n    };\n  },\n  [MarkdownTokenTypes.FENCE]: (token) => {\n    // The 'fence' token is emitted by markdown-it for triple backtick code blocks (```),\n    // which is the most common code block syntax in markdown. This ensures both indented\n    // and fenced code blocks are supported.\n    return {\n      type: BlockTypes.CODE_BLOCK,\n      attrs: {\n        language: token.info || null, // language after ``` if present\n      },\n      content: [\n        {\n          type: 'text',\n          text: token.content,\n        },\n      ],\n    };\n  },\n  [MarkdownTokenTypes.LINK]: (token, children) => {\n    applyMarkInPlace(children, {\n      type: MarkTypes.LINK,\n      attrs: {\n        href: token.attrGet('href'),\n        title: token.attrGet('title') || null,\n      },\n    });\n    return null;\n  },\n  [MarkdownTokenTypes.HR]: () => {\n    return {\n      type: BlockTypes.HR,\n    };\n  },\n  [MarkdownTokenTypes.DEL]: (_token, children) => {\n    applyMarkInPlace(children, { type: MarkTypes.STRIKE });\n    return null; // flatten children\n  },\n  [MarkdownTokenTypes.HARD_BREAK]: () => {\n    return {\n      type: BlockTypes.BR,\n    };\n  },\n  [MarkdownTokenTypes.SOFT_BREAK]: () => {\n    // Soft breaks are usually rendered as spaces in HTML, but you may want to handle them differently\n    return {\n      type: TextTypes.TEXT,\n      text: ' ',\n    };\n  },\n  // Table support (GFM tables are enabled by default in markdown-it)\n  [MarkdownTokenTypes.TABLE]: (_token, children) => ({ type: BlockTypes.TABLE, content: children }),\n  [MarkdownTokenTypes.THEAD]: () => null,\n  [MarkdownTokenTypes.TBODY]: () => null,\n  [MarkdownTokenTypes.TR]: (_token, children) => ({ type: BlockTypes.TABLE_ROW, content: children }),\n  [MarkdownTokenTypes.TH]: (_token, children) => ({\n    type: BlockTypes.TABLE_CELL,\n    attrs: { colspan: 1, rowspan: 1, colwidth: null },\n    content: [\n      {\n        type: BlockTypes.PARAGRAPH,\n        content: children || [],\n      },\n    ],\n  }),\n  [MarkdownTokenTypes.TD]: (_token, children) => ({\n    type: BlockTypes.TABLE_CELL,\n    attrs: { colspan: 1, rowspan: 1, colwidth: null },\n    content: [\n      {\n        type: BlockTypes.PARAGRAPH,\n        content: children || [],\n      },\n    ],\n  }),\n  // Strikethrough support (GFM strikethrough is enabled by default in markdown-it)\n  [MarkdownTokenTypes.S]: (_token, children) => {\n    applyMarkInPlace(children, { type: MarkTypes.STRIKE });\n    return null; // flatten children\n  },\n};\n\n/**\n * Converts Markdown string to Storyblok Richtext Document Node using resolvers.\n * @param markdown - The markdown string to convert\n * @param options - Optional custom resolvers\n * @returns StoryblokRichTextDocumentNode\n */\nexport function markdownToStoryblokRichtext(\n  markdown: string,\n  options: MarkdownParserOptions = {},\n): StoryblokRichTextDocumentNode {\n  // Parse markdown to tokens using markdown-it with GFM support and hard breaks\n  const md = new MarkdownIt({ html: false, linkify: true, typographer: true, breaks: true });\n  const tokens = md.parse(markdown, {});\n  const resolvers = { ...defaultResolvers, ...options.resolvers };\n\n  // Helper to walk tokens and build a tree\n  function walkTokens(tokens: MarkdownToken[], start = 0): [StoryblokRichTextDocumentNode[], number] {\n    const nodes: StoryblokRichTextDocumentNode[] = [];\n    let i = start;\n    while (i < tokens.length) {\n      const token = tokens[i];\n\n      // Handle inline tokens (which contain actual text and marks)\n      if (token.type === 'inline' && token.children) {\n        const [inlineNodes] = walkTokens(token.children, 0);\n        nodes.push(...inlineNodes);\n        i++;\n        continue;\n      }\n\n      if (token.nesting === 1) { // opening tag\n        const type = token.type;\n        const children: StoryblokRichTextDocumentNode[] = [];\n        i++;\n        while (i < tokens.length && !(tokens[i].type === type.replace('_open', '_close') && tokens[i].nesting === -1)) {\n          const [childNodes, consumed] = walkTokens(tokens, i);\n          children.push(...childNodes);\n          i += consumed;\n        }\n        const resolver = resolvers[type];\n        if (resolver) {\n          const node = resolver(token, children.length ? children : undefined);\n          if (node) {\n            nodes.push(node);\n          }\n          else {\n            // If resolver returns null, flatten children into parent\n            nodes.push(...children);\n          }\n        }\n        i++; // skip closing tag\n      }\n      else if (token.nesting === 0) { // self-closing or text\n        const resolver = resolvers[token.type];\n        if (resolver) {\n          const node = resolver(token, undefined);\n          if (node) {\n            nodes.push(node);\n          }\n        }\n        i++;\n      }\n      else if (token.nesting === -1) { // closing tag, return to parent\n        break;\n      }\n      else {\n        i++;\n      }\n    }\n    return [nodes, i - start];\n  }\n\n  // Convert all tokens to Storyblok nodes\n  const [content] = walkTokens(tokens);\n\n  // Return as Storyblok document node\n  return {\n    type: 'doc',\n    content,\n  };\n}\n"],"mappings":"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"}