(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ?  factory(exports, require('markdown-it')) :
  typeof define === 'function' && define.amd ? define(['exports', 'markdown-it'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.StoryblokRichtextMarkdownParser = {}), global.markdownit));
})(this, function(exports, markdown_it) {
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
markdown_it = __toESM(markdown_it);

//#region src/types/index.ts
let BlockTypes = /* @__PURE__ */ function(BlockTypes$1) {
	BlockTypes$1["DOCUMENT"] = "doc";
	BlockTypes$1["HEADING"] = "heading";
	BlockTypes$1["PARAGRAPH"] = "paragraph";
	BlockTypes$1["QUOTE"] = "blockquote";
	BlockTypes$1["OL_LIST"] = "ordered_list";
	BlockTypes$1["UL_LIST"] = "bullet_list";
	BlockTypes$1["LIST_ITEM"] = "list_item";
	BlockTypes$1["CODE_BLOCK"] = "code_block";
	BlockTypes$1["HR"] = "horizontal_rule";
	BlockTypes$1["BR"] = "hard_break";
	BlockTypes$1["IMAGE"] = "image";
	BlockTypes$1["EMOJI"] = "emoji";
	BlockTypes$1["COMPONENT"] = "blok";
	BlockTypes$1["TABLE"] = "table";
	BlockTypes$1["TABLE_ROW"] = "tableRow";
	BlockTypes$1["TABLE_CELL"] = "tableCell";
	BlockTypes$1["TABLE_HEADER"] = "tableHeader";
	return BlockTypes$1;
}({});
let MarkTypes = /* @__PURE__ */ function(MarkTypes$1) {
	MarkTypes$1["BOLD"] = "bold";
	MarkTypes$1["STRONG"] = "strong";
	MarkTypes$1["STRIKE"] = "strike";
	MarkTypes$1["UNDERLINE"] = "underline";
	MarkTypes$1["ITALIC"] = "italic";
	MarkTypes$1["CODE"] = "code";
	MarkTypes$1["LINK"] = "link";
	MarkTypes$1["ANCHOR"] = "anchor";
	MarkTypes$1["STYLED"] = "styled";
	MarkTypes$1["SUPERSCRIPT"] = "superscript";
	MarkTypes$1["SUBSCRIPT"] = "subscript";
	MarkTypes$1["TEXT_STYLE"] = "textStyle";
	MarkTypes$1["HIGHLIGHT"] = "highlight";
	return MarkTypes$1;
}({});
let TextTypes = /* @__PURE__ */ function(TextTypes$1) {
	TextTypes$1["TEXT"] = "text";
	return TextTypes$1;
}({});

//#endregion
//#region src/markdown-parser.ts
/**
* Supported Markdown token types as constants for maintainability and type safety.
* @see https://markdown-it.github.io/token-class.html
*/
const MarkdownTokenTypes = {
	HEADING: "heading_open",
	PARAGRAPH: "paragraph_open",
	TEXT: "text",
	STRONG: "strong_open",
	EMP: "em_open",
	ORDERED_LIST: "ordered_list_open",
	BULLET_LIST: "bullet_list_open",
	LIST_ITEM: "list_item_open",
	IMAGE: "image",
	BLOCKQUOTE: "blockquote_open",
	CODE_INLINE: "code_inline",
	CODE_BLOCK: "code_block",
	FENCE: "fence",
	LINK: "link_open",
	HR: "hr",
	DEL: "del_open",
	HARD_BREAK: "hardbreak",
	SOFT_BREAK: "softbreak",
	TABLE: "table_open",
	THEAD: "thead_open",
	TBODY: "tbody_open",
	TR: "tr_open",
	TH: "th_open",
	TD: "td_open",
	S: "s_open"
};
/**
* Mark all text nodes in-place (including nested inline content).
*/
function applyMarkInPlace(nodes, mark) {
	if (!nodes) return;
	for (const node of nodes) {
		if (node.type === MarkTypes.LINK && Array.isArray(node.content)) {
			const linkMark = {
				type: MarkTypes.LINK,
				attrs: node.attrs ?? null
			};
			applyMarkInPlace(node.content, linkMark);
			applyMarkInPlace(node.content, mark);
			nodes.splice(nodes.indexOf(node), 1, ...node.content);
			continue;
		}
		const existing = node.marks || [];
		node.marks = [...existing, mark];
	}
}
/**
* Default resolvers for supported Markdown token types.
* These map markdown-it tokens to Storyblok RichText nodes.
*/
const defaultResolvers = {
	[MarkdownTokenTypes.HEADING]: (token, children) => {
		const level = Number(token.tag.replace("h", ""));
		return {
			type: BlockTypes.HEADING,
			attrs: { level },
			content: children
		};
	},
	[MarkdownTokenTypes.PARAGRAPH]: (_token, children) => {
		return {
			type: BlockTypes.PARAGRAPH,
			content: children
		};
	},
	[MarkdownTokenTypes.TEXT]: (token) => {
		if (!token.content || token.content.trim() === "") return null;
		return {
			type: TextTypes.TEXT,
			text: token.content
		};
	},
	[MarkdownTokenTypes.STRONG]: (_token, children) => {
		applyMarkInPlace(children, { type: MarkTypes.BOLD });
		return null;
	},
	[MarkdownTokenTypes.EMP]: (_token, children) => {
		applyMarkInPlace(children, { type: MarkTypes.ITALIC });
		return null;
	},
	[MarkdownTokenTypes.ORDERED_LIST]: (_token, children) => {
		return {
			type: BlockTypes.OL_LIST,
			content: children
		};
	},
	[MarkdownTokenTypes.BULLET_LIST]: (_token, children) => {
		return {
			type: BlockTypes.UL_LIST,
			content: children
		};
	},
	[MarkdownTokenTypes.LIST_ITEM]: (_token, children) => {
		return {
			type: BlockTypes.LIST_ITEM,
			content: children
		};
	},
	[MarkdownTokenTypes.IMAGE]: (token) => {
		return {
			type: BlockTypes.IMAGE,
			attrs: {
				src: token.attrGet("src"),
				alt: token.content || token.attrGet("alt") || "",
				title: token.attrGet("title") || ""
			}
		};
	},
	[MarkdownTokenTypes.BLOCKQUOTE]: (_token, children) => {
		return {
			type: BlockTypes.QUOTE,
			content: children
		};
	},
	[MarkdownTokenTypes.CODE_INLINE]: (token) => {
		return {
			type: MarkTypes.CODE,
			text: token.content,
			marks: [{ type: MarkTypes.CODE }]
		};
	},
	[MarkdownTokenTypes.CODE_BLOCK]: (token) => {
		return {
			type: BlockTypes.CODE_BLOCK,
			attrs: { language: null },
			content: [{
				type: "text",
				text: token.content
			}]
		};
	},
	[MarkdownTokenTypes.FENCE]: (token) => {
		return {
			type: BlockTypes.CODE_BLOCK,
			attrs: { language: token.info || null },
			content: [{
				type: "text",
				text: token.content
			}]
		};
	},
	[MarkdownTokenTypes.LINK]: (token, children) => {
		applyMarkInPlace(children, {
			type: MarkTypes.LINK,
			attrs: {
				href: token.attrGet("href"),
				title: token.attrGet("title") || null
			}
		});
		return null;
	},
	[MarkdownTokenTypes.HR]: () => {
		return { type: BlockTypes.HR };
	},
	[MarkdownTokenTypes.DEL]: (_token, children) => {
		applyMarkInPlace(children, { type: MarkTypes.STRIKE });
		return null;
	},
	[MarkdownTokenTypes.HARD_BREAK]: () => {
		return { type: BlockTypes.BR };
	},
	[MarkdownTokenTypes.SOFT_BREAK]: () => {
		return {
			type: TextTypes.TEXT,
			text: " "
		};
	},
	[MarkdownTokenTypes.TABLE]: (_token, children) => ({
		type: BlockTypes.TABLE,
		content: children
	}),
	[MarkdownTokenTypes.THEAD]: () => null,
	[MarkdownTokenTypes.TBODY]: () => null,
	[MarkdownTokenTypes.TR]: (_token, children) => ({
		type: BlockTypes.TABLE_ROW,
		content: children
	}),
	[MarkdownTokenTypes.TH]: (_token, children) => ({
		type: BlockTypes.TABLE_CELL,
		attrs: {
			colspan: 1,
			rowspan: 1,
			colwidth: null
		},
		content: [{
			type: BlockTypes.PARAGRAPH,
			content: children || []
		}]
	}),
	[MarkdownTokenTypes.TD]: (_token, children) => ({
		type: BlockTypes.TABLE_CELL,
		attrs: {
			colspan: 1,
			rowspan: 1,
			colwidth: null
		},
		content: [{
			type: BlockTypes.PARAGRAPH,
			content: children || []
		}]
	}),
	[MarkdownTokenTypes.S]: (_token, children) => {
		applyMarkInPlace(children, { type: MarkTypes.STRIKE });
		return null;
	}
};
/**
* Converts Markdown string to Storyblok Richtext Document Node using resolvers.
* @param markdown - The markdown string to convert
* @param options - Optional custom resolvers
* @returns StoryblokRichTextDocumentNode
*/
function markdownToStoryblokRichtext(markdown, options = {}) {
	const md = new markdown_it.default({
		html: false,
		linkify: true,
		typographer: true,
		breaks: true
	});
	const tokens = md.parse(markdown, {});
	const resolvers = {
		...defaultResolvers,
		...options.resolvers
	};
	function walkTokens(tokens$1, start = 0) {
		const nodes = [];
		let i = start;
		while (i < tokens$1.length) {
			const token = tokens$1[i];
			if (token.type === "inline" && token.children) {
				const [inlineNodes] = walkTokens(token.children, 0);
				nodes.push(...inlineNodes);
				i++;
				continue;
			}
			if (token.nesting === 1) {
				const type = token.type;
				const children = [];
				i++;
				while (i < tokens$1.length && !(tokens$1[i].type === type.replace("_open", "_close") && tokens$1[i].nesting === -1)) {
					const [childNodes, consumed] = walkTokens(tokens$1, i);
					children.push(...childNodes);
					i += consumed;
				}
				const resolver = resolvers[type];
				if (resolver) {
					const node = resolver(token, children.length ? children : void 0);
					if (node) nodes.push(node);
					else nodes.push(...children);
				}
				i++;
			} else if (token.nesting === 0) {
				const resolver = resolvers[token.type];
				if (resolver) {
					const node = resolver(token, void 0);
					if (node) nodes.push(node);
				}
				i++;
			} else if (token.nesting === -1) break;
			else i++;
		}
		return [nodes, i - start];
	}
	const [content] = walkTokens(tokens);
	return {
		type: "doc",
		content
	};
}

//#endregion
exports.MarkdownTokenTypes = MarkdownTokenTypes;
exports.markdownToStoryblokRichtext = markdownToStoryblokRichtext;
});
//# sourceMappingURL=markdown-parser.umd.js.map