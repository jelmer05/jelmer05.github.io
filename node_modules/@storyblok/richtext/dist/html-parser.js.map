{"version":3,"file":"html-parser.js","names":["markNodePartial: Partial<MarkNode> & { type: MarkNode['type'] }","contentProcessed: StoryblokRichTextDocumentNode[]","newParagraph: StoryblokRichTextDocumentNode | null","marks: MarkNode[]","attrs: { language?: string }","defaultResolvers: Record<string, HTMLNodeElementResolver>","node: HTMLNodeText","node: HTMLNodeElement","options: Required<HTMLParserOptions>","node: HTMLNodeElement | HTMLNodeText","node: NodeHTMLParserNodeText","tag: string","node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText","parent: HTMLNodeElement | null","elementNode: HTMLNodeElement","element: NodeHTMLParserNodeElement","defaultOptions: Required<HTMLParserOptions>","html: string","options: HTMLParserOptions"],"sources":["../src/html-parser.ts"],"sourcesContent":["import {\n  BlockTypes,\n  type MarkNode,\n  MarkTypes,\n  type StoryblokRichTextDocumentNode,\n  TextTypes,\n} from './types';\nimport {\n  type HTMLElement as NodeHTMLParserNodeElement,\n  type TextNode as NodeHTMLParserNodeText,\n  NodeType,\n  parse,\n  valid,\n} from 'node-html-parser';\nimport { BLOCK_LEVEL_TAGS, SELF_CLOSING_TAGS } from './utils';\n\nexport interface StyleOption {\n  name: string;\n  value: string;\n}\n\nexport type RichTextAttrs = Record<string, string | number | boolean | null>;\n\nexport type HTMLAttrs = Record<string, string>;\n\nexport interface HTMLParserOptions {\n  allowCustomAttributes?: boolean;\n  normalizeWhitespace?: boolean;\n  resolvers?: Record<string, HTMLNodeElementResolver>;\n  styleOptions?: StyleOption[];\n}\n\nexport interface HTMLNodeElement {\n  attrs: HTMLAttrs;\n  children?: (HTMLNodeElement | HTMLNodeText)[];\n  parent: HTMLNodeElement | null;\n  tag: keyof HTMLElementTagNameMap;\n  text: string;\n  type: 'element';\n}\n\nexport interface HTMLNodeText {\n  isLayoutWhitespace: boolean;\n  isWhitespace: boolean;\n  parent: HTMLNodeElement | null;\n  text: string;\n  type: 'text';\n}\n\nexport interface HTMLNodeElementResolverOptions {\n  allowCustomAttributes?: boolean;\n  styleOptions?: StyleOption[];\n}\n\nexport type HTMLNodeElementResolver = (\n  node: HTMLNodeElement,\n  content: StoryblokRichTextDocumentNode[] | undefined,\n  options: HTMLNodeElementResolverOptions\n) => StoryblokRichTextDocumentNode | StoryblokRichTextDocumentNode[] | null;\n\nexport const HTMLTags = {\n  H1: 'h1',\n  H2: 'h2',\n  H3: 'h3',\n  H4: 'h4',\n  H5: 'h5',\n  H6: 'h6',\n  P: 'p',\n  OL: 'ol',\n  UL: 'ul',\n  LI: 'li',\n  TABLE: 'table',\n  THEAD: 'thead',\n  TBODY: 'tbody',\n  TR: 'tr',\n  TH: 'th',\n  TD: 'td',\n  BLOCKQUOTE: 'blockquote',\n  PRE: 'pre',\n  SPAN: 'span',\n  STRONG: 'strong',\n  B: 'b',\n  EM: 'em',\n  I: 'i',\n  A: 'a',\n  DEL: 'del',\n  S: 's',\n  CODE: 'code',\n  IMG: 'img',\n  HR: 'hr',\n  BR: 'br',\n};\n\nconst tagMap = {\n  [HTMLTags.H1]: BlockTypes.HEADING,\n  [HTMLTags.H2]: BlockTypes.HEADING,\n  [HTMLTags.H3]: BlockTypes.HEADING,\n  [HTMLTags.H4]: BlockTypes.HEADING,\n  [HTMLTags.H5]: BlockTypes.HEADING,\n  [HTMLTags.H6]: BlockTypes.HEADING,\n  [HTMLTags.P]: BlockTypes.PARAGRAPH,\n  [HTMLTags.OL]: BlockTypes.OL_LIST,\n  [HTMLTags.UL]: BlockTypes.UL_LIST,\n  [HTMLTags.LI]: BlockTypes.LIST_ITEM,\n  [HTMLTags.BLOCKQUOTE]: BlockTypes.QUOTE,\n  [HTMLTags.PRE]: BlockTypes.CODE_BLOCK,\n  [HTMLTags.TABLE]: BlockTypes.TABLE,\n  [HTMLTags.THEAD]: BlockTypes.TABLE_HEADER,\n  [HTMLTags.TR]: BlockTypes.TABLE_ROW,\n  [HTMLTags.TH]: BlockTypes.TABLE_CELL,\n  [HTMLTags.TD]: BlockTypes.TABLE_CELL,\n  [HTMLTags.IMG]: BlockTypes.IMAGE,\n  [HTMLTags.HR]: BlockTypes.HR,\n  [HTMLTags.BR]: BlockTypes.BR,\n} as const;\n\nfunction createMark(markNodePartial: Partial<MarkNode> & { type: MarkNode['type'] }): MarkNode {\n  return {\n    ...markNodePartial,\n    content: [],\n  };\n}\n\nfunction resolveBlock({\n  attrs,\n  marks,\n}: {\n  attrs?: RichTextAttrs;\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content) => {\n    const unsupportedAttributes = Object.keys(node.attrs).filter(attr => !attrs?.[attr]);\n    for (const attr of unsupportedAttributes) {\n      console.warn(`[StoryblokRichText] - \\`${attr}\\` \"${node.attrs[attr]}\" on \\`<${node.tag}>\\` can not be transformed to rich text.`);\n    }\n\n    return {\n      type: tagMap[node.tag],\n      content,\n      attrs,\n      marks,\n    };\n  };\n}\n\nfunction resolveBlockWithParagraphWrappers({\n  attrs,\n  marks,\n}: {\n  attrs?: RichTextAttrs;\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content = [], options) => {\n    const contentProcessed: StoryblokRichTextDocumentNode[] = [];\n    let newParagraph: StoryblokRichTextDocumentNode | null = null;\n\n    for (const child of content) {\n      // 1. Wrap text nodes in a paragraph\n      if (child.type === TextTypes.TEXT) {\n        if (!newParagraph) {\n          newParagraph = { type: BlockTypes.PARAGRAPH, content: [] };\n        }\n        newParagraph.content?.push(child);\n      }\n\n      if (child.type !== TextTypes.TEXT) {\n        // 2. If a text node is followed by a non-text node, push the paragraph\n        if (newParagraph) {\n          contentProcessed.push(newParagraph);\n          newParagraph = null;\n        }\n        contentProcessed.push(child);\n      }\n    }\n\n    // 3. If there's a pending paragraph, push it\n    if (newParagraph) {\n      contentProcessed.push(newParagraph);\n    }\n\n    return resolveBlock({ attrs, marks })(node, contentProcessed, options);\n  };\n}\n\nfunction resolveText({\n  marks: extraMarks = [],\n}: {\n  marks?: MarkNode[];\n} = {}): HTMLNodeElementResolver {\n  return (node, content = [], { styleOptions }) => {\n    const marks: MarkNode[] = [...extraMarks];\n    const nodeStyles = node.attrs.class ? node.attrs.class.split(' ') : [];\n    const allowedStyles = styleOptions?.map(opt => opt.value) ?? [];\n    const styles = allowedStyles.filter(x => nodeStyles.includes(x));\n    if (styles.length > 0) {\n      marks.push(createMark({\n        type: MarkTypes.STYLED,\n        attrs: {\n          class: styles.join(' '),\n        },\n      }));\n    }\n    const removedStyles = nodeStyles.filter(x => !allowedStyles.includes(x));\n    for (const removedStyle of removedStyles) {\n      console.warn(`[StoryblokRichText] - \\`class\\` \"${removedStyle}\" on \\`<${node.tag}>\\` can not be transformed to rich text.`);\n    }\n\n    // Apply marks to child text nodes, preserving any existing marks\n    return content.map((child) => {\n      if (child.type === TextTypes.TEXT) {\n        if (marks.length === 0) {\n          return child;\n        }\n        const allMarks = child.marks ? [...child.marks, ...marks] : marks;\n        return { ...child, marks: allMarks };\n      }\n      return child;\n    });\n  };\n}\n\nfunction resolveCode(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    // We treat <code> tags separately if they're in <pre> tags\n    if (node.parent?.tag === HTMLTags.PRE) {\n      return null;\n    }\n\n    return resolveText({ marks: [createMark({ type: MarkTypes.CODE })] })(node, content, options);\n  };\n}\n\nfunction resolveHeading(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const levelMatch = node.tag.match(/h(\\d)/);\n    if (!levelMatch) {\n      throw new Error('Invalid heading tag!');\n    }\n\n    const level = Number(levelMatch[1]);\n    return resolveBlock({\n      attrs: { level },\n    })(node, content, options);\n  };\n}\n\nfunction resolveTableCell(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const attrs = {\n      colspan: node.attrs.colspan ?? 1,\n      rowspan: node.attrs.rowspan ?? 1,\n      colwidth: node.attrs.colwidth ?? null,\n    };\n\n    return resolveBlockWithParagraphWrappers({ attrs })(node, content, options);\n  };\n}\n\nfunction resolvePre(): HTMLNodeElementResolver {\n  return (node, _, options) => {\n    if (node.children && node.children.length > 1) {\n      throw new Error('Multiple child nodes within `<pre>` are not allowed!');\n    }\n\n    const attrs: { language?: string } = {};\n    const child = node.children?.[0];\n    if (!child) {\n      return resolveBlock({ attrs })(node, [], options);\n    }\n\n    const text = child.text;\n    if (child.type === 'element' && child.tag === HTMLTags.CODE) {\n      const languageMatch = child.attrs.class?.match(/(?:^|\\s)language-([\\w-]+)(?:\\s|$)/);\n      if (languageMatch) {\n        attrs.language = languageMatch[1];\n      }\n    }\n    const content = [{ type: TextTypes.TEXT, text }];\n\n    return resolveBlock({ attrs })(node, content, options);\n  };\n}\n\nfunction resolveAnchor(): HTMLNodeElementResolver {\n  return (node, content, { allowCustomAttributes, styleOptions }) => {\n    const {\n      href,\n      target,\n      id,\n      ...custom\n    }: { href?: string; target?: string; id?: string } & Record<\n      string,\n      string\n    > = node.attrs;\n    const type = !href && id ? MarkTypes.ANCHOR : MarkTypes.LINK;\n    const mark = createMark({\n      type,\n      attrs: {\n        href,\n        target,\n        anchor: id,\n        custom: allowCustomAttributes && Object.keys(custom).length > 0 ? custom : undefined,\n      },\n    });\n\n    return resolveText({ marks: [mark] })(node, content, { allowCustomAttributes, styleOptions });\n  };\n}\n\nfunction resolveImage(): HTMLNodeElementResolver {\n  return (node, content, options) => {\n    const {\n      src,\n      alt,\n      title,\n    }: { src?: string; alt?: string; title?: string } & Record<\n      string,\n      string\n    > = node.attrs;\n    const attrs = {\n      src,\n      alt,\n      title,\n    };\n\n    return resolveBlock({ attrs })(node, content, options);\n  };\n}\n\nfunction resolveContentOnly(): HTMLNodeElementResolver {\n  return (_, content) => {\n    return content || null;\n  };\n}\n\n/**\n * Default resolvers for supported HTML tags.\n */\nconst defaultResolvers: Record<string, HTMLNodeElementResolver> = {\n  // Block-level elements\n  [HTMLTags.H1]: resolveHeading(),\n  [HTMLTags.H2]: resolveHeading(),\n  [HTMLTags.H3]: resolveHeading(),\n  [HTMLTags.H4]: resolveHeading(),\n  [HTMLTags.H5]: resolveHeading(),\n  [HTMLTags.H6]: resolveHeading(),\n  [HTMLTags.P]: resolveBlock(),\n  [HTMLTags.OL]: resolveBlock(),\n  [HTMLTags.UL]: resolveBlock(),\n  [HTMLTags.LI]: resolveBlockWithParagraphWrappers(),\n  [HTMLTags.BLOCKQUOTE]: resolveBlockWithParagraphWrappers(),\n  [HTMLTags.PRE]: resolvePre(),\n  [HTMLTags.TABLE]: resolveBlock(),\n  [HTMLTags.THEAD]: resolveContentOnly(),\n  [HTMLTags.TBODY]: resolveContentOnly(),\n  [HTMLTags.TR]: resolveBlock(),\n  [HTMLTags.TH]: resolveTableCell(),\n  [HTMLTags.TD]: resolveTableCell(),\n\n  // Inline elements\n  [HTMLTags.SPAN]: resolveText(),\n  [HTMLTags.STRONG]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),\n  [HTMLTags.B]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),\n  [HTMLTags.EM]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),\n  [HTMLTags.I]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),\n  [HTMLTags.A]: resolveAnchor(),\n  [HTMLTags.DEL]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),\n  [HTMLTags.S]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),\n  [HTMLTags.CODE]: resolveCode(),\n\n  // Self-closing tags\n  [HTMLTags.IMG]: resolveImage(),\n  [HTMLTags.HR]: resolveBlock(),\n  [HTMLTags.BR]: resolveBlock(),\n};\n\nfunction textToRichTextNode(node: HTMLNodeText) {\n  return {\n    type: TextTypes.TEXT,\n    text: node.text,\n  } satisfies StoryblokRichTextDocumentNode;\n}\n\nfunction elementToRichTextNode(node: HTMLNodeElement, options: Required<HTMLParserOptions>) {\n  const resolver = options.resolvers[node.tag];\n  if (!resolver) {\n    throw new Error(`No resolver specified for tag \"${node.tag}\"!`);\n  }\n\n  const children = (node.children || [])\n    .map(n => toRichTextNode(n, options))\n    .flat()\n    .filter(c => c !== null);\n\n  return resolver(node, children, options);\n}\n\nfunction removeWhitespaceFromNode(node: HTMLNodeElement | HTMLNodeText) {\n  const nodeProcessed = { ...node };\n  // Remove node if it is not affecting rendering\n  const isUnnecessaryWhitespace = nodeProcessed.type === 'text' && nodeProcessed.isWhitespace && !nodeProcessed.isLayoutWhitespace;\n  if (isUnnecessaryWhitespace) {\n    return null;\n  }\n\n  // Replace newlines with spaces except within tags with preformatted text\n  const hasFormattedText = 'tag' in nodeProcessed && ['pre', 'textarea', 'script', 'style'].includes(nodeProcessed.tag);\n  if (!hasFormattedText) {\n    nodeProcessed.text = nodeProcessed.text.replace(/(\\r\\n|\\n|\\r)/g, ' ');\n  }\n\n  return nodeProcessed;\n}\n\n/**\n * Converts a node to a Rich Text node.\n */\nfunction toRichTextNode(\n  node: HTMLNodeElement | HTMLNodeText,\n  options: Required<HTMLParserOptions>,\n): StoryblokRichTextDocumentNode | StoryblokRichTextDocumentNode[] | null {\n  let nodeProcessed = { ...node };\n  if (options.normalizeWhitespace) {\n    const normalizedNode = removeWhitespaceFromNode(node);\n    if (!normalizedNode) {\n      return null;\n    }\n\n    nodeProcessed = normalizedNode;\n  }\n\n  if (nodeProcessed.type === 'text') {\n    return textToRichTextNode(nodeProcessed);\n  }\n\n  return elementToRichTextNode(nodeProcessed, options);\n}\n\nfunction getPreviousElementSibling(node: NodeHTMLParserNodeText): NodeHTMLParserNodeElement | null {\n  const index = node.parentNode.childNodes.indexOf(node);\n  const previousSibling = node.parentNode.childNodes[index - 1];\n  if (!previousSibling) {\n    return null;\n  }\n\n  if (previousSibling.nodeType !== NodeType.ELEMENT_NODE) {\n    return getPreviousElementSibling(previousSibling as NodeHTMLParserNodeText);\n  }\n\n  return previousSibling as NodeHTMLParserNodeElement;\n}\n\nfunction getNextElementSibling(node: NodeHTMLParserNodeText): NodeHTMLParserNodeElement | null {\n  const index = node.parentNode.childNodes.indexOf(node);\n  const nextSibling = node.parentNode.childNodes[index + 1];\n  if (!nextSibling) {\n    return null;\n  }\n\n  if (nextSibling.nodeType !== NodeType.ELEMENT_NODE) {\n    return getNextElementSibling(nextSibling as NodeHTMLParserNodeText);\n  }\n\n  return nextSibling as NodeHTMLParserNodeElement;\n}\n\nconst tagsNotRequiringWhitespace = [...BLOCK_LEVEL_TAGS, ...SELF_CLOSING_TAGS];\nfunction tagRequiresWhitespace(tag: string) {\n  return !tagsNotRequiringWhitespace.includes(tag.toLowerCase());\n}\n\n/**\n * Adapts a `node-html-parse` node to a custom parser node format.\n * We don't want to expose the `node-html-parse` types directly, so this\n * function adapts the nodes to our custom format.\n */\nfunction adaptParserNode(node: NodeHTMLParserNodeElement, parent?: HTMLNodeElement | null): HTMLNodeElement;\nfunction adaptParserNode(node: NodeHTMLParserNodeText, parent?: HTMLNodeElement | null): HTMLNodeText;\nfunction adaptParserNode(node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText, parent?: HTMLNodeElement | null): HTMLNodeElement | HTMLNodeText;\nfunction adaptParserNode(\n  node: NodeHTMLParserNodeElement | NodeHTMLParserNodeText,\n  parent: HTMLNodeElement | null = null,\n): HTMLNodeElement | HTMLNodeText {\n  if ('trimmedRawText' in node) {\n    const previousElementSibling = getPreviousElementSibling(node);\n    const previousSiblingRequiresWhitespace = !previousElementSibling || tagRequiresWhitespace(previousElementSibling.tagName);\n    const nextElementSibling = getNextElementSibling(node);\n    const nextSiblingRequiresWhitespace = !nextElementSibling || tagRequiresWhitespace(nextElementSibling.tagName);\n    const isLayoutWhitespace = node.isWhitespace && (previousSiblingRequiresWhitespace || nextSiblingRequiresWhitespace);\n\n    return {\n      type: 'text',\n      text: node.text,\n      parent,\n      isWhitespace: node.isWhitespace,\n      isLayoutWhitespace,\n    } satisfies HTMLNodeText;\n  }\n\n  const elementNode: HTMLNodeElement = {\n    type: 'element',\n    tag: node.tagName.toLowerCase() as keyof HTMLElementTagNameMap,\n    text: node.text,\n    attrs: node.attributes,\n    parent,\n  };\n  elementNode.children = node.childNodes.map(child =>\n    adaptParserNode(child as NodeHTMLParserNodeElement | NodeHTMLParserNodeText, elementNode),\n  );\n\n  return elementNode;\n}\n\n/**\n * The rich text format does not support elements nested inside of anchors. For\n * simpler transformation logic, we transform the HTML tree beforehand to\n * accommodate this limitation.\n *\n * For example, the structure:\n * `<p>Please <a>click <b>here</b> for more</a> info.</p>`\n * will be transformed into:\n * `<p>Please <a>click </a><b><a>here</a></b><a> for more</a> info.</p>`\n *\n * @param element The `NodeHTMLParserNodeElement` to search for and normalize links within.\n * @throws {Error} Throws an error if a nested element within an anchor contains non-text nodes.\n */\nfunction normalizeLinks(element: NodeHTMLParserNodeElement) {\n  for (const anchor of element.querySelectorAll('a')) {\n    const hasOnlyTextNodes = !anchor.childNodes.some(c => c.nodeType === NodeType.ELEMENT_NODE);\n    if (hasOnlyTextNodes) {\n      continue;\n    }\n\n    const normalizedLinks = [];\n    for (const child of anchor.childNodes) {\n      if (child.nodeType === NodeType.TEXT_NODE) {\n        const a = anchor.clone();\n        a.childNodes.forEach(c => c.remove());\n        // @ts-expect-error node-html-parser types are wrong\n        a.appendChild(child);\n        normalizedLinks.push(a);\n        continue;\n      }\n\n      for (const text of child.childNodes) {\n        if (text.nodeType !== NodeType.TEXT_NODE) {\n          throw new Error('Non-text nodes within anchors are not supported!');\n        }\n        const a = anchor.clone();\n        a.childNodes.forEach(c => c.remove());\n        // @ts-expect-error node-html-parser types are wrong\n        a.appendChild(text);\n        // @ts-expect-error node-html-parser types are wrong\n        child.appendChild(a);\n      }\n      normalizedLinks.push(child);\n    }\n    anchor.replaceWith(...normalizedLinks);\n  }\n}\n\nexport const defaultOptions: Required<HTMLParserOptions> = {\n  allowCustomAttributes: false,\n  normalizeWhitespace: true,\n  resolvers: defaultResolvers,\n  styleOptions: [],\n} as const;\n\n/**\n * Convert HTML to Storyblok Rich Text format.\n */\nexport function htmlToStoryblokRichtext(\n  html: string,\n  options: HTMLParserOptions = {},\n): StoryblokRichTextDocumentNode {\n  if (!valid(html)) {\n    throw new Error('Invalid HTML: The provided string could not be parsed. Common causes include unclosed or mismatched tags!');\n  }\n\n  const root = parse(html, { blockTextElements: {} });\n  normalizeLinks(root);\n\n  const content = root.childNodes\n    .map(parserNode =>\n      toRichTextNode(adaptParserNode(parserNode as NodeHTMLParserNodeElement | NodeHTMLParserNodeText), {\n        ...defaultOptions,\n        ...options,\n        resolvers: {\n          ...defaultOptions.resolvers,\n          ...options.resolvers,\n        },\n      }),\n    )\n    .flat()\n    .filter(c => c !== null);\n\n  return {\n    type: 'doc',\n    content,\n  };\n}\n"],"mappings":"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"}