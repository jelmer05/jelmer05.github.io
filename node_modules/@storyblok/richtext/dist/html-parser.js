import { BlockTypes, MarkTypes, TextTypes } from "./types-Ca8wrPRx.js";
import { BLOCK_LEVEL_TAGS, SELF_CLOSING_TAGS } from "./utils-B8TElHJA.js";
import { NodeType, parse, valid } from "node-html-parser";

//#region src/html-parser.ts
const HTMLTags = {
	H1: "h1",
	H2: "h2",
	H3: "h3",
	H4: "h4",
	H5: "h5",
	H6: "h6",
	P: "p",
	OL: "ol",
	UL: "ul",
	LI: "li",
	TABLE: "table",
	THEAD: "thead",
	TBODY: "tbody",
	TR: "tr",
	TH: "th",
	TD: "td",
	BLOCKQUOTE: "blockquote",
	PRE: "pre",
	SPAN: "span",
	STRONG: "strong",
	B: "b",
	EM: "em",
	I: "i",
	A: "a",
	DEL: "del",
	S: "s",
	CODE: "code",
	IMG: "img",
	HR: "hr",
	BR: "br"
};
const tagMap = {
	[HTMLTags.H1]: BlockTypes.HEADING,
	[HTMLTags.H2]: BlockTypes.HEADING,
	[HTMLTags.H3]: BlockTypes.HEADING,
	[HTMLTags.H4]: BlockTypes.HEADING,
	[HTMLTags.H5]: BlockTypes.HEADING,
	[HTMLTags.H6]: BlockTypes.HEADING,
	[HTMLTags.P]: BlockTypes.PARAGRAPH,
	[HTMLTags.OL]: BlockTypes.OL_LIST,
	[HTMLTags.UL]: BlockTypes.UL_LIST,
	[HTMLTags.LI]: BlockTypes.LIST_ITEM,
	[HTMLTags.BLOCKQUOTE]: BlockTypes.QUOTE,
	[HTMLTags.PRE]: BlockTypes.CODE_BLOCK,
	[HTMLTags.TABLE]: BlockTypes.TABLE,
	[HTMLTags.THEAD]: BlockTypes.TABLE_HEADER,
	[HTMLTags.TR]: BlockTypes.TABLE_ROW,
	[HTMLTags.TH]: BlockTypes.TABLE_CELL,
	[HTMLTags.TD]: BlockTypes.TABLE_CELL,
	[HTMLTags.IMG]: BlockTypes.IMAGE,
	[HTMLTags.HR]: BlockTypes.HR,
	[HTMLTags.BR]: BlockTypes.BR
};
function createMark(markNodePartial) {
	return {
		...markNodePartial,
		content: []
	};
}
function resolveBlock({ attrs, marks } = {}) {
	return (node, content) => {
		const unsupportedAttributes = Object.keys(node.attrs).filter((attr) => !attrs?.[attr]);
		for (const attr of unsupportedAttributes) console.warn(`[StoryblokRichText] - \`${attr}\` "${node.attrs[attr]}" on \`<${node.tag}>\` can not be transformed to rich text.`);
		return {
			type: tagMap[node.tag],
			content,
			attrs,
			marks
		};
	};
}
function resolveBlockWithParagraphWrappers({ attrs, marks } = {}) {
	return (node, content = [], options) => {
		const contentProcessed = [];
		let newParagraph = null;
		for (const child of content) {
			if (child.type === TextTypes.TEXT) {
				if (!newParagraph) newParagraph = {
					type: BlockTypes.PARAGRAPH,
					content: []
				};
				newParagraph.content?.push(child);
			}
			if (child.type !== TextTypes.TEXT) {
				if (newParagraph) {
					contentProcessed.push(newParagraph);
					newParagraph = null;
				}
				contentProcessed.push(child);
			}
		}
		if (newParagraph) contentProcessed.push(newParagraph);
		return resolveBlock({
			attrs,
			marks
		})(node, contentProcessed, options);
	};
}
function resolveText({ marks: extraMarks = [] } = {}) {
	return (node, content = [], { styleOptions }) => {
		const marks = [...extraMarks];
		const nodeStyles = node.attrs.class ? node.attrs.class.split(" ") : [];
		const allowedStyles = styleOptions?.map((opt) => opt.value) ?? [];
		const styles = allowedStyles.filter((x) => nodeStyles.includes(x));
		if (styles.length > 0) marks.push(createMark({
			type: MarkTypes.STYLED,
			attrs: { class: styles.join(" ") }
		}));
		const removedStyles = nodeStyles.filter((x) => !allowedStyles.includes(x));
		for (const removedStyle of removedStyles) console.warn(`[StoryblokRichText] - \`class\` "${removedStyle}" on \`<${node.tag}>\` can not be transformed to rich text.`);
		return content.map((child) => {
			if (child.type === TextTypes.TEXT) {
				if (marks.length === 0) return child;
				const allMarks = child.marks ? [...child.marks, ...marks] : marks;
				return {
					...child,
					marks: allMarks
				};
			}
			return child;
		});
	};
}
function resolveCode() {
	return (node, content, options) => {
		if (node.parent?.tag === HTMLTags.PRE) return null;
		return resolveText({ marks: [createMark({ type: MarkTypes.CODE })] })(node, content, options);
	};
}
function resolveHeading() {
	return (node, content, options) => {
		const levelMatch = node.tag.match(/h(\d)/);
		if (!levelMatch) throw new Error("Invalid heading tag!");
		const level = Number(levelMatch[1]);
		return resolveBlock({ attrs: { level } })(node, content, options);
	};
}
function resolveTableCell() {
	return (node, content, options) => {
		const attrs = {
			colspan: node.attrs.colspan ?? 1,
			rowspan: node.attrs.rowspan ?? 1,
			colwidth: node.attrs.colwidth ?? null
		};
		return resolveBlockWithParagraphWrappers({ attrs })(node, content, options);
	};
}
function resolvePre() {
	return (node, _, options) => {
		if (node.children && node.children.length > 1) throw new Error("Multiple child nodes within `<pre>` are not allowed!");
		const attrs = {};
		const child = node.children?.[0];
		if (!child) return resolveBlock({ attrs })(node, [], options);
		const text = child.text;
		if (child.type === "element" && child.tag === HTMLTags.CODE) {
			const languageMatch = child.attrs.class?.match(/(?:^|\s)language-([\w-]+)(?:\s|$)/);
			if (languageMatch) attrs.language = languageMatch[1];
		}
		const content = [{
			type: TextTypes.TEXT,
			text
		}];
		return resolveBlock({ attrs })(node, content, options);
	};
}
function resolveAnchor() {
	return (node, content, { allowCustomAttributes, styleOptions }) => {
		const { href, target, id,...custom } = node.attrs;
		const type = !href && id ? MarkTypes.ANCHOR : MarkTypes.LINK;
		const mark = createMark({
			type,
			attrs: {
				href,
				target,
				anchor: id,
				custom: allowCustomAttributes && Object.keys(custom).length > 0 ? custom : void 0
			}
		});
		return resolveText({ marks: [mark] })(node, content, {
			allowCustomAttributes,
			styleOptions
		});
	};
}
function resolveImage() {
	return (node, content, options) => {
		const { src, alt, title } = node.attrs;
		const attrs = {
			src,
			alt,
			title
		};
		return resolveBlock({ attrs })(node, content, options);
	};
}
function resolveContentOnly() {
	return (_, content) => {
		return content || null;
	};
}
/**
* Default resolvers for supported HTML tags.
*/
const defaultResolvers = {
	[HTMLTags.H1]: resolveHeading(),
	[HTMLTags.H2]: resolveHeading(),
	[HTMLTags.H3]: resolveHeading(),
	[HTMLTags.H4]: resolveHeading(),
	[HTMLTags.H5]: resolveHeading(),
	[HTMLTags.H6]: resolveHeading(),
	[HTMLTags.P]: resolveBlock(),
	[HTMLTags.OL]: resolveBlock(),
	[HTMLTags.UL]: resolveBlock(),
	[HTMLTags.LI]: resolveBlockWithParagraphWrappers(),
	[HTMLTags.BLOCKQUOTE]: resolveBlockWithParagraphWrappers(),
	[HTMLTags.PRE]: resolvePre(),
	[HTMLTags.TABLE]: resolveBlock(),
	[HTMLTags.THEAD]: resolveContentOnly(),
	[HTMLTags.TBODY]: resolveContentOnly(),
	[HTMLTags.TR]: resolveBlock(),
	[HTMLTags.TH]: resolveTableCell(),
	[HTMLTags.TD]: resolveTableCell(),
	[HTMLTags.SPAN]: resolveText(),
	[HTMLTags.STRONG]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),
	[HTMLTags.B]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),
	[HTMLTags.EM]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),
	[HTMLTags.I]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),
	[HTMLTags.A]: resolveAnchor(),
	[HTMLTags.DEL]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),
	[HTMLTags.S]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),
	[HTMLTags.CODE]: resolveCode(),
	[HTMLTags.IMG]: resolveImage(),
	[HTMLTags.HR]: resolveBlock(),
	[HTMLTags.BR]: resolveBlock()
};
function textToRichTextNode(node) {
	return {
		type: TextTypes.TEXT,
		text: node.text
	};
}
function elementToRichTextNode(node, options) {
	const resolver = options.resolvers[node.tag];
	if (!resolver) throw new Error(`No resolver specified for tag "${node.tag}"!`);
	const children = (node.children || []).map((n) => toRichTextNode(n, options)).flat().filter((c) => c !== null);
	return resolver(node, children, options);
}
function removeWhitespaceFromNode(node) {
	const nodeProcessed = { ...node };
	const isUnnecessaryWhitespace = nodeProcessed.type === "text" && nodeProcessed.isWhitespace && !nodeProcessed.isLayoutWhitespace;
	if (isUnnecessaryWhitespace) return null;
	const hasFormattedText = "tag" in nodeProcessed && [
		"pre",
		"textarea",
		"script",
		"style"
	].includes(nodeProcessed.tag);
	if (!hasFormattedText) nodeProcessed.text = nodeProcessed.text.replace(/(\r\n|\n|\r)/g, " ");
	return nodeProcessed;
}
/**
* Converts a node to a Rich Text node.
*/
function toRichTextNode(node, options) {
	let nodeProcessed = { ...node };
	if (options.normalizeWhitespace) {
		const normalizedNode = removeWhitespaceFromNode(node);
		if (!normalizedNode) return null;
		nodeProcessed = normalizedNode;
	}
	if (nodeProcessed.type === "text") return textToRichTextNode(nodeProcessed);
	return elementToRichTextNode(nodeProcessed, options);
}
function getPreviousElementSibling(node) {
	const index = node.parentNode.childNodes.indexOf(node);
	const previousSibling = node.parentNode.childNodes[index - 1];
	if (!previousSibling) return null;
	if (previousSibling.nodeType !== NodeType.ELEMENT_NODE) return getPreviousElementSibling(previousSibling);
	return previousSibling;
}
function getNextElementSibling(node) {
	const index = node.parentNode.childNodes.indexOf(node);
	const nextSibling = node.parentNode.childNodes[index + 1];
	if (!nextSibling) return null;
	if (nextSibling.nodeType !== NodeType.ELEMENT_NODE) return getNextElementSibling(nextSibling);
	return nextSibling;
}
const tagsNotRequiringWhitespace = [...BLOCK_LEVEL_TAGS, ...SELF_CLOSING_TAGS];
function tagRequiresWhitespace(tag) {
	return !tagsNotRequiringWhitespace.includes(tag.toLowerCase());
}
function adaptParserNode(node, parent = null) {
	if ("trimmedRawText" in node) {
		const previousElementSibling = getPreviousElementSibling(node);
		const previousSiblingRequiresWhitespace = !previousElementSibling || tagRequiresWhitespace(previousElementSibling.tagName);
		const nextElementSibling = getNextElementSibling(node);
		const nextSiblingRequiresWhitespace = !nextElementSibling || tagRequiresWhitespace(nextElementSibling.tagName);
		const isLayoutWhitespace = node.isWhitespace && (previousSiblingRequiresWhitespace || nextSiblingRequiresWhitespace);
		return {
			type: "text",
			text: node.text,
			parent,
			isWhitespace: node.isWhitespace,
			isLayoutWhitespace
		};
	}
	const elementNode = {
		type: "element",
		tag: node.tagName.toLowerCase(),
		text: node.text,
		attrs: node.attributes,
		parent
	};
	elementNode.children = node.childNodes.map((child) => adaptParserNode(child, elementNode));
	return elementNode;
}
/**
* The rich text format does not support elements nested inside of anchors. For
* simpler transformation logic, we transform the HTML tree beforehand to
* accommodate this limitation.
*
* For example, the structure:
* `<p>Please <a>click <b>here</b> for more</a> info.</p>`
* will be transformed into:
* `<p>Please <a>click </a><b><a>here</a></b><a> for more</a> info.</p>`
*
* @param element The `NodeHTMLParserNodeElement` to search for and normalize links within.
* @throws {Error} Throws an error if a nested element within an anchor contains non-text nodes.
*/
function normalizeLinks(element) {
	for (const anchor of element.querySelectorAll("a")) {
		const hasOnlyTextNodes = !anchor.childNodes.some((c) => c.nodeType === NodeType.ELEMENT_NODE);
		if (hasOnlyTextNodes) continue;
		const normalizedLinks = [];
		for (const child of anchor.childNodes) {
			if (child.nodeType === NodeType.TEXT_NODE) {
				const a = anchor.clone();
				a.childNodes.forEach((c) => c.remove());
				a.appendChild(child);
				normalizedLinks.push(a);
				continue;
			}
			for (const text of child.childNodes) {
				if (text.nodeType !== NodeType.TEXT_NODE) throw new Error("Non-text nodes within anchors are not supported!");
				const a = anchor.clone();
				a.childNodes.forEach((c) => c.remove());
				a.appendChild(text);
				child.appendChild(a);
			}
			normalizedLinks.push(child);
		}
		anchor.replaceWith(...normalizedLinks);
	}
}
const defaultOptions = {
	allowCustomAttributes: false,
	normalizeWhitespace: true,
	resolvers: defaultResolvers,
	styleOptions: []
};
/**
* Convert HTML to Storyblok Rich Text format.
*/
function htmlToStoryblokRichtext(html, options = {}) {
	if (!valid(html)) throw new Error("Invalid HTML: The provided string could not be parsed. Common causes include unclosed or mismatched tags!");
	const root = parse(html, { blockTextElements: {} });
	normalizeLinks(root);
	const content = root.childNodes.map((parserNode) => toRichTextNode(adaptParserNode(parserNode), {
		...defaultOptions,
		...options,
		resolvers: {
			...defaultOptions.resolvers,
			...options.resolvers
		}
	})).flat().filter((c) => c !== null);
	return {
		type: "doc",
		content
	};
}

//#endregion
export { HTMLTags, defaultOptions, htmlToStoryblokRichtext };
//# sourceMappingURL=html-parser.js.map