import { BlockTypes, LinkTargets, LinkTypes, MarkTypes, TextTypes } from "./types-Ca8wrPRx.js";
import { SELF_CLOSING_TAGS, attrsToString, attrsToStyle, cleanObject, escapeHtml } from "./utils-B8TElHJA.js";

//#region src/images-optimization.ts
function optimizeImage(src, options) {
	if (!options) return {
		src,
		attrs: {}
	};
	let w = 0;
	let h = 0;
	const attrs = {};
	const filterParams = [];
	function validateAndPushFilterParam(value, min, max, filter, filterParams$1) {
		if (typeof value !== "number" || value <= min || value >= max) console.warn(`[StoryblokRichText] - ${filter.charAt(0).toUpperCase() + filter.slice(1)} value must be a number between ${min} and ${max} (inclusive)`);
		else filterParams$1.push(`${filter}(${value})`);
	}
	if (typeof options === "object") {
		if (options.width !== void 0) if (typeof options.width === "number" && options.width >= 0) {
			attrs.width = options.width;
			w = options.width;
		} else console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0");
		if (options.height !== void 0) if (typeof options.height === "number" && options.height >= 0) {
			attrs.height = options.height;
			h = options.height;
		} else console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0");
		if (options.height === 0 && options.width === 0) {
			delete attrs.width;
			delete attrs.height;
			console.warn("[StoryblokRichText] - Width and height values cannot both be 0");
		}
		if (options.loading && ["lazy", "eager"].includes(options.loading)) attrs.loading = options.loading;
		if (options.class) attrs.class = options.class;
		if (options.filters) {
			const { filters } = options || {};
			const { blur, brightness, fill, format, grayscale, quality, rotate } = filters || {};
			if (blur) validateAndPushFilterParam(blur, 0, 100, "blur", filterParams);
			if (quality) validateAndPushFilterParam(quality, 0, 100, "quality", filterParams);
			if (brightness) validateAndPushFilterParam(brightness, 0, 100, "brightness", filterParams);
			if (fill) filterParams.push(`fill(${fill})`);
			if (grayscale) filterParams.push(`grayscale()`);
			if (rotate && [
				0,
				90,
				180,
				270
			].includes(options.filters.rotate || 0)) filterParams.push(`rotate(${rotate})`);
			if (format && [
				"webp",
				"png",
				"jpeg"
			].includes(format)) filterParams.push(`format(${format})`);
		}
		if (options.srcset) attrs.srcset = options.srcset.map((entry) => {
			if (typeof entry === "number") return `${src}/m/${entry}x0/${filterParams.length > 0 ? `filters:${filterParams.join(":")}` : ""} ${entry}w`;
			if (Array.isArray(entry) && entry.length === 2) {
				const [entryWidth, entryHeight] = entry;
				return `${src}/m/${entryWidth}x${entryHeight}/${filterParams.length > 0 ? `filters:${filterParams.join(":")}` : ""} ${entryWidth}w`;
			} else {
				console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
				return void 0;
			}
		}).join(", ");
		if (options.sizes) attrs.sizes = options.sizes.join(", ");
	}
	let resultSrc = `${src}/m/`;
	if (w > 0 || h > 0) resultSrc = `${resultSrc}${w}x${h}/`;
	if (filterParams.length > 0) resultSrc = `${resultSrc}filters:${filterParams.join(":")}`;
	return {
		src: resultSrc,
		attrs
	};
}

//#endregion
//#region src/richtext.ts
/**
* Default render function that creates an HTML string for a given tag, attributes, and children.
*
* @template T
* @param {string} tag
* @param {BlockAttributes} [attrs]
* @param {T} children
* @return {*}  {T}
*/
function defaultRenderFn(tag, attrs = {}, children) {
	const attrsString = attrsToString(attrs);
	const tagString = attrsString ? `${tag} ${attrsString}` : tag;
	const content = Array.isArray(children) ? children.join("") : children || "";
	if (!tag) return content;
	else if (SELF_CLOSING_TAGS.includes(tag)) return `<${tagString}>`;
	return `<${tagString}>${content}</${tag}>`;
}
/**
* Creates a rich text resolver with the given options.
*
* @export
* @template T
* @param {StoryblokRichTextOptions<T>} [options]
* @return {*}
*/
function richTextResolver(options = {}) {
	const keyCounters = /* @__PURE__ */ new Map();
	const { renderFn = defaultRenderFn, textFn = escapeHtml, resolvers = {}, optimizeImages = false, keyedResolvers = false } = options;
	const isExternalRenderFn = renderFn !== defaultRenderFn;
	/**
	* Processes attributes and styles for a node
	* @param attrs The node attributes
	* @returns Processed attributes with styles
	*/
	const processAttributes = (attrs = {}) => {
		const { textAlign, class: className, id: idName, style: existingStyle,...rest } = attrs;
		const styles = [];
		if (existingStyle) styles.push(existingStyle.endsWith(";") ? existingStyle : `${existingStyle};`);
		if (textAlign) styles.push(`text-align: ${textAlign};`);
		return cleanObject({
			...rest,
			class: className,
			id: idName,
			...styles.length > 0 ? { style: styles.join(" ") } : {}
		});
	};
	const nodeResolver = (tag) => (node, context) => {
		const attributes = processAttributes(node.attrs);
		return context.render(tag, attributes, node.children || null);
	};
	const imageResolver = (node, context) => {
		const { src, alt, title, srcset, sizes } = node.attrs || {};
		let finalSrc = src;
		let finalAttrs = {};
		if (optimizeImages) {
			const { src: optimizedSrc, attrs: optimizedAttrs } = optimizeImage(src, optimizeImages);
			finalSrc = optimizedSrc;
			finalAttrs = optimizedAttrs;
		}
		const imgAttrs = {
			src: finalSrc,
			alt,
			title,
			srcset,
			sizes,
			...finalAttrs
		};
		return context.render("img", cleanObject(imgAttrs));
	};
	const headingResolver = (node, context) => {
		const { level,...rest } = node.attrs || {};
		const attributes = processAttributes(rest);
		return context.render(`h${level}`, attributes, node.children);
	};
	const emojiResolver = (node, context) => {
		const internalImg = context.render("img", {
			src: node.attrs?.fallbackImage,
			alt: node.attrs?.alt,
			style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
			draggable: "false",
			loading: "lazy"
		});
		return context.render("span", {
			"data-type": "emoji",
			"data-name": node.attrs?.name,
			"data-emoji": node.attrs?.emoji
		}, internalImg);
	};
	const codeBlockResolver = (node, context) => {
		return context.render("pre", node.attrs || {}, context.render("code", {}, node.children || ""));
	};
	const markResolver = (tag, styled = false) => ({ text, attrs }, context) => {
		const { class: className, id: idName,...styleAttrs } = attrs || {};
		const attributes = styled ? {
			class: className,
			id: idName,
			style: attrsToStyle(styleAttrs) || void 0
		} : attrs || {};
		return context.render(tag, cleanObject(attributes), text);
	};
	const renderToT = (node) => {
		return render(node);
	};
	const textResolver = (node) => {
		const { marks,...rest } = node;
		if ("text" in node) {
			if (marks) return marks.reduce((text, mark) => renderToT({
				...mark,
				text
			}), renderToT({
				...rest,
				children: rest.children
			}));
			const attributes = node.attrs || {};
			if (keyedResolvers) {
				const currentCount = keyCounters.get("txt") || 0;
				keyCounters.set("txt", currentCount + 1);
				attributes.key = `txt-${currentCount}`;
			}
			return textFn(rest.text, attributes);
		}
		return "";
	};
	const linkResolver = (node, context) => {
		const { linktype, href, anchor,...rest } = node.attrs || {};
		let finalHref = "";
		switch (linktype) {
			case LinkTypes.ASSET:
			case LinkTypes.URL:
				finalHref = href;
				break;
			case LinkTypes.EMAIL:
				finalHref = `mailto:${href}`;
				break;
			case LinkTypes.STORY:
				finalHref = href;
				if (anchor) finalHref = `${finalHref}#${anchor}`;
				break;
			default:
				finalHref = href;
				break;
		}
		const attributes = { ...rest };
		if (finalHref) attributes.href = finalHref;
		return context.render("a", attributes, node.text);
	};
	const componentResolver = (node, context) => {
		console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage");
		return context.render("span", {
			blok: node?.attrs?.body[0],
			id: node.attrs?.id,
			style: "display: none"
		});
	};
	const tableResolver = (node, context) => {
		const attributes = processAttributes(node.attrs);
		const children = node.children || null;
		return context.render("table", attributes, context.render("tbody", {}, children));
	};
	const tableRowResolver = (node, context) => {
		const attributes = processAttributes(node.attrs);
		return context.render("tr", attributes, node.children);
	};
	const tableCellResolver = (node, context) => {
		const { colspan, rowspan, colwidth, backgroundColor, textAlign,...rest } = node.attrs || {};
		const styles = [];
		if (colwidth) styles.push(`width: ${colwidth}px;`);
		if (backgroundColor) styles.push(`background-color: ${backgroundColor};`);
		if (textAlign) styles.push(`text-align: ${textAlign};`);
		const attributes = {
			...rest,
			...colspan > 1 ? { colspan } : {},
			...rowspan > 1 ? { rowspan } : {},
			...styles.length > 0 ? { style: styles.join(" ") } : {}
		};
		return context.render("td", cleanObject(attributes), node.children);
	};
	const tableHeaderResolver = (node, context) => {
		const { colspan, rowspan, colwidth, backgroundColor, textAlign,...rest } = node.attrs || {};
		const styles = [];
		if (colwidth) styles.push(`width: ${colwidth}px;`);
		if (backgroundColor) styles.push(`background-color: ${backgroundColor};`);
		if (textAlign) styles.push(`text-align: ${textAlign};`);
		const attributes = {
			...rest,
			...colspan > 1 ? { colspan } : {},
			...rowspan > 1 ? { rowspan } : {},
			...styles.length > 0 ? { style: styles.join(" ") } : {}
		};
		return context.render("th", cleanObject(attributes), node.children);
	};
	const originalResolvers = new Map([
		[BlockTypes.DOCUMENT, nodeResolver("")],
		[BlockTypes.HEADING, headingResolver],
		[BlockTypes.PARAGRAPH, nodeResolver("p")],
		[BlockTypes.UL_LIST, nodeResolver("ul")],
		[BlockTypes.OL_LIST, nodeResolver("ol")],
		[BlockTypes.LIST_ITEM, nodeResolver("li")],
		[BlockTypes.IMAGE, imageResolver],
		[BlockTypes.EMOJI, emojiResolver],
		[BlockTypes.CODE_BLOCK, codeBlockResolver],
		[BlockTypes.HR, nodeResolver("hr")],
		[BlockTypes.BR, nodeResolver("br")],
		[BlockTypes.QUOTE, nodeResolver("blockquote")],
		[BlockTypes.COMPONENT, componentResolver],
		[TextTypes.TEXT, textResolver],
		[MarkTypes.LINK, linkResolver],
		[MarkTypes.ANCHOR, linkResolver],
		[MarkTypes.STYLED, markResolver("span", true)],
		[MarkTypes.BOLD, markResolver("strong")],
		[MarkTypes.TEXT_STYLE, markResolver("span", true)],
		[MarkTypes.ITALIC, markResolver("em")],
		[MarkTypes.UNDERLINE, markResolver("u")],
		[MarkTypes.STRIKE, markResolver("s")],
		[MarkTypes.CODE, markResolver("code")],
		[MarkTypes.SUPERSCRIPT, markResolver("sup")],
		[MarkTypes.SUBSCRIPT, markResolver("sub")],
		[MarkTypes.HIGHLIGHT, markResolver("mark")],
		[BlockTypes.TABLE, tableResolver],
		[BlockTypes.TABLE_ROW, tableRowResolver],
		[BlockTypes.TABLE_CELL, tableCellResolver],
		[BlockTypes.TABLE_HEADER, tableHeaderResolver]
	]);
	const mergedResolvers = new Map([...originalResolvers, ...Object.entries(resolvers).map(([type, resolver]) => [type, resolver])]);
	const createRenderContext = () => {
		const contextRenderFn = (tag, attrs = {}, children) => {
			if (keyedResolvers && tag) {
				const currentCount = keyCounters.get(tag) || 0;
				keyCounters.set(tag, currentCount + 1);
				attrs.key = `${tag}-${currentCount}`;
			}
			return renderFn(tag, attrs, children);
		};
		const context = {
			render: contextRenderFn,
			originalResolvers,
			mergedResolvers
		};
		return context;
	};
	function renderNode(node) {
		const resolver = mergedResolvers.get(node.type);
		if (!resolver) {
			console.error("<Storyblok>", `No resolver found for node type ${node.type}`);
			return "";
		}
		const context = createRenderContext();
		if (node.type === "text") return resolver(node, context);
		const children = node.content ? node.content.map(render) : void 0;
		return resolver({
			...node,
			children
		}, context);
	}
	/**
	* Renders a rich text node coming from Storyblok.
	*
	* @param {StoryblokRichTextNode<T>} node
	* @return {*}  {T}
	*
	* @example
	*
	* ```typescript
	* import StoryblokClient from 'storyblok-js-client'
	* import { richTextResolver } from '@storyblok/richtext'
	*
	* const storyblok = new StoryblokClient({
	*  accessToken:  import.meta.env.VITE_STORYBLOK_TOKEN,
	* })
	*
	* const story = await client.get('cdn/stories/home', {
	*  version: 'draft',
	* })
	*
	* const html = richTextResolver().render(story.data.story.content.richtext)
	* ```
	*
	*/
	function render(node) {
		if (node.type === "doc") return isExternalRenderFn ? node.content.map(renderNode) : node.content.map(renderNode).join("");
		return Array.isArray(node) ? node.map(renderNode) : renderNode(node);
	}
	return { render };
}

//#endregion
export { BlockTypes, LinkTargets, LinkTypes, MarkTypes, TextTypes, richTextResolver };
//# sourceMappingURL=index.js.map