(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ?  factory(exports, require('node-html-parser')) :
  typeof define === 'function' && define.amd ? define(['exports', 'node-html-parser'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.StoryblokRichtextHtmlParser = {}), global.NodeHtmlParser));
})(this, function(exports, node_html_parser) {
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
node_html_parser = __toESM(node_html_parser);

//#region src/types/index.ts
let BlockTypes = /* @__PURE__ */ function(BlockTypes$1) {
	BlockTypes$1["DOCUMENT"] = "doc";
	BlockTypes$1["HEADING"] = "heading";
	BlockTypes$1["PARAGRAPH"] = "paragraph";
	BlockTypes$1["QUOTE"] = "blockquote";
	BlockTypes$1["OL_LIST"] = "ordered_list";
	BlockTypes$1["UL_LIST"] = "bullet_list";
	BlockTypes$1["LIST_ITEM"] = "list_item";
	BlockTypes$1["CODE_BLOCK"] = "code_block";
	BlockTypes$1["HR"] = "horizontal_rule";
	BlockTypes$1["BR"] = "hard_break";
	BlockTypes$1["IMAGE"] = "image";
	BlockTypes$1["EMOJI"] = "emoji";
	BlockTypes$1["COMPONENT"] = "blok";
	BlockTypes$1["TABLE"] = "table";
	BlockTypes$1["TABLE_ROW"] = "tableRow";
	BlockTypes$1["TABLE_CELL"] = "tableCell";
	BlockTypes$1["TABLE_HEADER"] = "tableHeader";
	return BlockTypes$1;
}({});
let MarkTypes = /* @__PURE__ */ function(MarkTypes$1) {
	MarkTypes$1["BOLD"] = "bold";
	MarkTypes$1["STRONG"] = "strong";
	MarkTypes$1["STRIKE"] = "strike";
	MarkTypes$1["UNDERLINE"] = "underline";
	MarkTypes$1["ITALIC"] = "italic";
	MarkTypes$1["CODE"] = "code";
	MarkTypes$1["LINK"] = "link";
	MarkTypes$1["ANCHOR"] = "anchor";
	MarkTypes$1["STYLED"] = "styled";
	MarkTypes$1["SUPERSCRIPT"] = "superscript";
	MarkTypes$1["SUBSCRIPT"] = "subscript";
	MarkTypes$1["TEXT_STYLE"] = "textStyle";
	MarkTypes$1["HIGHLIGHT"] = "highlight";
	return MarkTypes$1;
}({});
let TextTypes = /* @__PURE__ */ function(TextTypes$1) {
	TextTypes$1["TEXT"] = "text";
	return TextTypes$1;
}({});

//#endregion
//#region src/utils/index.ts
const SELF_CLOSING_TAGS = [
	"area",
	"base",
	"br",
	"col",
	"embed",
	"hr",
	"img",
	"input",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
];
const BLOCK_LEVEL_TAGS = [
	"address",
	"article",
	"aside",
	"blockquote",
	"canvas",
	"dd",
	"div",
	"dl",
	"dt",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"header",
	"hgroup",
	"hr",
	"li",
	"main",
	"nav",
	"noscript",
	"ol",
	"output",
	"p",
	"pre",
	"section",
	"table",
	"tfoot",
	"ul",
	"video"
];

//#endregion
//#region src/html-parser.ts
const HTMLTags = {
	H1: "h1",
	H2: "h2",
	H3: "h3",
	H4: "h4",
	H5: "h5",
	H6: "h6",
	P: "p",
	OL: "ol",
	UL: "ul",
	LI: "li",
	TABLE: "table",
	THEAD: "thead",
	TBODY: "tbody",
	TR: "tr",
	TH: "th",
	TD: "td",
	BLOCKQUOTE: "blockquote",
	PRE: "pre",
	SPAN: "span",
	STRONG: "strong",
	B: "b",
	EM: "em",
	I: "i",
	A: "a",
	DEL: "del",
	S: "s",
	CODE: "code",
	IMG: "img",
	HR: "hr",
	BR: "br"
};
const tagMap = {
	[HTMLTags.H1]: BlockTypes.HEADING,
	[HTMLTags.H2]: BlockTypes.HEADING,
	[HTMLTags.H3]: BlockTypes.HEADING,
	[HTMLTags.H4]: BlockTypes.HEADING,
	[HTMLTags.H5]: BlockTypes.HEADING,
	[HTMLTags.H6]: BlockTypes.HEADING,
	[HTMLTags.P]: BlockTypes.PARAGRAPH,
	[HTMLTags.OL]: BlockTypes.OL_LIST,
	[HTMLTags.UL]: BlockTypes.UL_LIST,
	[HTMLTags.LI]: BlockTypes.LIST_ITEM,
	[HTMLTags.BLOCKQUOTE]: BlockTypes.QUOTE,
	[HTMLTags.PRE]: BlockTypes.CODE_BLOCK,
	[HTMLTags.TABLE]: BlockTypes.TABLE,
	[HTMLTags.THEAD]: BlockTypes.TABLE_HEADER,
	[HTMLTags.TR]: BlockTypes.TABLE_ROW,
	[HTMLTags.TH]: BlockTypes.TABLE_CELL,
	[HTMLTags.TD]: BlockTypes.TABLE_CELL,
	[HTMLTags.IMG]: BlockTypes.IMAGE,
	[HTMLTags.HR]: BlockTypes.HR,
	[HTMLTags.BR]: BlockTypes.BR
};
function createMark(markNodePartial) {
	return {
		...markNodePartial,
		content: []
	};
}
function resolveBlock({ attrs, marks } = {}) {
	return (node, content) => {
		const unsupportedAttributes = Object.keys(node.attrs).filter((attr) => !attrs?.[attr]);
		for (const attr of unsupportedAttributes) console.warn(`[StoryblokRichText] - \`${attr}\` "${node.attrs[attr]}" on \`<${node.tag}>\` can not be transformed to rich text.`);
		return {
			type: tagMap[node.tag],
			content,
			attrs,
			marks
		};
	};
}
function resolveBlockWithParagraphWrappers({ attrs, marks } = {}) {
	return (node, content = [], options) => {
		const contentProcessed = [];
		let newParagraph = null;
		for (const child of content) {
			if (child.type === TextTypes.TEXT) {
				if (!newParagraph) newParagraph = {
					type: BlockTypes.PARAGRAPH,
					content: []
				};
				newParagraph.content?.push(child);
			}
			if (child.type !== TextTypes.TEXT) {
				if (newParagraph) {
					contentProcessed.push(newParagraph);
					newParagraph = null;
				}
				contentProcessed.push(child);
			}
		}
		if (newParagraph) contentProcessed.push(newParagraph);
		return resolveBlock({
			attrs,
			marks
		})(node, contentProcessed, options);
	};
}
function resolveText({ marks: extraMarks = [] } = {}) {
	return (node, content = [], { styleOptions }) => {
		const marks = [...extraMarks];
		const nodeStyles = node.attrs.class ? node.attrs.class.split(" ") : [];
		const allowedStyles = styleOptions?.map((opt) => opt.value) ?? [];
		const styles = allowedStyles.filter((x) => nodeStyles.includes(x));
		if (styles.length > 0) marks.push(createMark({
			type: MarkTypes.STYLED,
			attrs: { class: styles.join(" ") }
		}));
		const removedStyles = nodeStyles.filter((x) => !allowedStyles.includes(x));
		for (const removedStyle of removedStyles) console.warn(`[StoryblokRichText] - \`class\` "${removedStyle}" on \`<${node.tag}>\` can not be transformed to rich text.`);
		return content.map((child) => {
			if (child.type === TextTypes.TEXT) {
				if (marks.length === 0) return child;
				const allMarks = child.marks ? [...child.marks, ...marks] : marks;
				return {
					...child,
					marks: allMarks
				};
			}
			return child;
		});
	};
}
function resolveCode() {
	return (node, content, options) => {
		if (node.parent?.tag === HTMLTags.PRE) return null;
		return resolveText({ marks: [createMark({ type: MarkTypes.CODE })] })(node, content, options);
	};
}
function resolveHeading() {
	return (node, content, options) => {
		const levelMatch = node.tag.match(/h(\d)/);
		if (!levelMatch) throw new Error("Invalid heading tag!");
		const level = Number(levelMatch[1]);
		return resolveBlock({ attrs: { level } })(node, content, options);
	};
}
function resolveTableCell() {
	return (node, content, options) => {
		const attrs = {
			colspan: node.attrs.colspan ?? 1,
			rowspan: node.attrs.rowspan ?? 1,
			colwidth: node.attrs.colwidth ?? null
		};
		return resolveBlockWithParagraphWrappers({ attrs })(node, content, options);
	};
}
function resolvePre() {
	return (node, _, options) => {
		if (node.children && node.children.length > 1) throw new Error("Multiple child nodes within `<pre>` are not allowed!");
		const attrs = {};
		const child = node.children?.[0];
		if (!child) return resolveBlock({ attrs })(node, [], options);
		const text = child.text;
		if (child.type === "element" && child.tag === HTMLTags.CODE) {
			const languageMatch = child.attrs.class?.match(/(?:^|\s)language-([\w-]+)(?:\s|$)/);
			if (languageMatch) attrs.language = languageMatch[1];
		}
		const content = [{
			type: TextTypes.TEXT,
			text
		}];
		return resolveBlock({ attrs })(node, content, options);
	};
}
function resolveAnchor() {
	return (node, content, { allowCustomAttributes, styleOptions }) => {
		const { href, target, id,...custom } = node.attrs;
		const type = !href && id ? MarkTypes.ANCHOR : MarkTypes.LINK;
		const mark = createMark({
			type,
			attrs: {
				href,
				target,
				anchor: id,
				custom: allowCustomAttributes && Object.keys(custom).length > 0 ? custom : void 0
			}
		});
		return resolveText({ marks: [mark] })(node, content, {
			allowCustomAttributes,
			styleOptions
		});
	};
}
function resolveImage() {
	return (node, content, options) => {
		const { src, alt, title } = node.attrs;
		const attrs = {
			src,
			alt,
			title
		};
		return resolveBlock({ attrs })(node, content, options);
	};
}
function resolveContentOnly() {
	return (_, content) => {
		return content || null;
	};
}
/**
* Default resolvers for supported HTML tags.
*/
const defaultResolvers = {
	[HTMLTags.H1]: resolveHeading(),
	[HTMLTags.H2]: resolveHeading(),
	[HTMLTags.H3]: resolveHeading(),
	[HTMLTags.H4]: resolveHeading(),
	[HTMLTags.H5]: resolveHeading(),
	[HTMLTags.H6]: resolveHeading(),
	[HTMLTags.P]: resolveBlock(),
	[HTMLTags.OL]: resolveBlock(),
	[HTMLTags.UL]: resolveBlock(),
	[HTMLTags.LI]: resolveBlockWithParagraphWrappers(),
	[HTMLTags.BLOCKQUOTE]: resolveBlockWithParagraphWrappers(),
	[HTMLTags.PRE]: resolvePre(),
	[HTMLTags.TABLE]: resolveBlock(),
	[HTMLTags.THEAD]: resolveContentOnly(),
	[HTMLTags.TBODY]: resolveContentOnly(),
	[HTMLTags.TR]: resolveBlock(),
	[HTMLTags.TH]: resolveTableCell(),
	[HTMLTags.TD]: resolveTableCell(),
	[HTMLTags.SPAN]: resolveText(),
	[HTMLTags.STRONG]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),
	[HTMLTags.B]: resolveText({ marks: [createMark({ type: MarkTypes.BOLD })] }),
	[HTMLTags.EM]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),
	[HTMLTags.I]: resolveText({ marks: [createMark({ type: MarkTypes.ITALIC })] }),
	[HTMLTags.A]: resolveAnchor(),
	[HTMLTags.DEL]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),
	[HTMLTags.S]: resolveText({ marks: [createMark({ type: MarkTypes.STRIKE })] }),
	[HTMLTags.CODE]: resolveCode(),
	[HTMLTags.IMG]: resolveImage(),
	[HTMLTags.HR]: resolveBlock(),
	[HTMLTags.BR]: resolveBlock()
};
function textToRichTextNode(node) {
	return {
		type: TextTypes.TEXT,
		text: node.text
	};
}
function elementToRichTextNode(node, options) {
	const resolver = options.resolvers[node.tag];
	if (!resolver) throw new Error(`No resolver specified for tag "${node.tag}"!`);
	const children = (node.children || []).map((n) => toRichTextNode(n, options)).flat().filter((c) => c !== null);
	return resolver(node, children, options);
}
function removeWhitespaceFromNode(node) {
	const nodeProcessed = { ...node };
	const isUnnecessaryWhitespace = nodeProcessed.type === "text" && nodeProcessed.isWhitespace && !nodeProcessed.isLayoutWhitespace;
	if (isUnnecessaryWhitespace) return null;
	const hasFormattedText = "tag" in nodeProcessed && [
		"pre",
		"textarea",
		"script",
		"style"
	].includes(nodeProcessed.tag);
	if (!hasFormattedText) nodeProcessed.text = nodeProcessed.text.replace(/(\r\n|\n|\r)/g, " ");
	return nodeProcessed;
}
/**
* Converts a node to a Rich Text node.
*/
function toRichTextNode(node, options) {
	let nodeProcessed = { ...node };
	if (options.normalizeWhitespace) {
		const normalizedNode = removeWhitespaceFromNode(node);
		if (!normalizedNode) return null;
		nodeProcessed = normalizedNode;
	}
	if (nodeProcessed.type === "text") return textToRichTextNode(nodeProcessed);
	return elementToRichTextNode(nodeProcessed, options);
}
function getPreviousElementSibling(node) {
	const index = node.parentNode.childNodes.indexOf(node);
	const previousSibling = node.parentNode.childNodes[index - 1];
	if (!previousSibling) return null;
	if (previousSibling.nodeType !== node_html_parser.NodeType.ELEMENT_NODE) return getPreviousElementSibling(previousSibling);
	return previousSibling;
}
function getNextElementSibling(node) {
	const index = node.parentNode.childNodes.indexOf(node);
	const nextSibling = node.parentNode.childNodes[index + 1];
	if (!nextSibling) return null;
	if (nextSibling.nodeType !== node_html_parser.NodeType.ELEMENT_NODE) return getNextElementSibling(nextSibling);
	return nextSibling;
}
const tagsNotRequiringWhitespace = [...BLOCK_LEVEL_TAGS, ...SELF_CLOSING_TAGS];
function tagRequiresWhitespace(tag) {
	return !tagsNotRequiringWhitespace.includes(tag.toLowerCase());
}
function adaptParserNode(node, parent = null) {
	if ("trimmedRawText" in node) {
		const previousElementSibling = getPreviousElementSibling(node);
		const previousSiblingRequiresWhitespace = !previousElementSibling || tagRequiresWhitespace(previousElementSibling.tagName);
		const nextElementSibling = getNextElementSibling(node);
		const nextSiblingRequiresWhitespace = !nextElementSibling || tagRequiresWhitespace(nextElementSibling.tagName);
		const isLayoutWhitespace = node.isWhitespace && (previousSiblingRequiresWhitespace || nextSiblingRequiresWhitespace);
		return {
			type: "text",
			text: node.text,
			parent,
			isWhitespace: node.isWhitespace,
			isLayoutWhitespace
		};
	}
	const elementNode = {
		type: "element",
		tag: node.tagName.toLowerCase(),
		text: node.text,
		attrs: node.attributes,
		parent
	};
	elementNode.children = node.childNodes.map((child) => adaptParserNode(child, elementNode));
	return elementNode;
}
/**
* The rich text format does not support elements nested inside of anchors. For
* simpler transformation logic, we transform the HTML tree beforehand to
* accommodate this limitation.
*
* For example, the structure:
* `<p>Please <a>click <b>here</b> for more</a> info.</p>`
* will be transformed into:
* `<p>Please <a>click </a><b><a>here</a></b><a> for more</a> info.</p>`
*
* @param element The `NodeHTMLParserNodeElement` to search for and normalize links within.
* @throws {Error} Throws an error if a nested element within an anchor contains non-text nodes.
*/
function normalizeLinks(element) {
	for (const anchor of element.querySelectorAll("a")) {
		const hasOnlyTextNodes = !anchor.childNodes.some((c) => c.nodeType === node_html_parser.NodeType.ELEMENT_NODE);
		if (hasOnlyTextNodes) continue;
		const normalizedLinks = [];
		for (const child of anchor.childNodes) {
			if (child.nodeType === node_html_parser.NodeType.TEXT_NODE) {
				const a = anchor.clone();
				a.childNodes.forEach((c) => c.remove());
				a.appendChild(child);
				normalizedLinks.push(a);
				continue;
			}
			for (const text of child.childNodes) {
				if (text.nodeType !== node_html_parser.NodeType.TEXT_NODE) throw new Error("Non-text nodes within anchors are not supported!");
				const a = anchor.clone();
				a.childNodes.forEach((c) => c.remove());
				a.appendChild(text);
				child.appendChild(a);
			}
			normalizedLinks.push(child);
		}
		anchor.replaceWith(...normalizedLinks);
	}
}
const defaultOptions = {
	allowCustomAttributes: false,
	normalizeWhitespace: true,
	resolvers: defaultResolvers,
	styleOptions: []
};
/**
* Convert HTML to Storyblok Rich Text format.
*/
function htmlToStoryblokRichtext(html, options = {}) {
	if (!(0, node_html_parser.valid)(html)) throw new Error("Invalid HTML: The provided string could not be parsed. Common causes include unclosed or mismatched tags!");
	const root = (0, node_html_parser.parse)(html, { blockTextElements: {} });
	normalizeLinks(root);
	const content = root.childNodes.map((parserNode) => toRichTextNode(adaptParserNode(parserNode), {
		...defaultOptions,
		...options,
		resolvers: {
			...defaultOptions.resolvers,
			...options.resolvers
		}
	})).flat().filter((c) => c !== null);
	return {
		type: "doc",
		content
	};
}

//#endregion
exports.HTMLTags = HTMLTags;
exports.defaultOptions = defaultOptions;
exports.htmlToStoryblokRichtext = htmlToStoryblokRichtext;
});
//# sourceMappingURL=html-parser.umd.js.map